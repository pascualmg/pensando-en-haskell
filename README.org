#+TITLE: Pensando en Haskell
#+AUTHOR: pascualmg
#+DATE: 2025
#+OPTIONS: toc:2 num:nil
#+PROPERTY: header-args:haskell :results value :exports both

#+begin_quote
âš ï¸ *IMPORTANTE*: Este proyecto usa ~nixos-25.05~ (stable) NO ~nixos-unstable~.

RazÃ³n: Compatibilidad entre HLS y GHC 9.8.4. Ver secciÃ³n [[*~GHC ABIs don't match!~ (IMPORTANTE)][Troubleshooting â†’ GHC ABIs don't match]].
#+end_quote

* README Interactivo ğŸ®

Este README estÃ¡ en formato Org-mode, lo que significa que los snippets de cÃ³digo Haskell son *ejecutables* directamente en Emacs:

1. Coloca el cursor en cualquier bloque ~#+begin_src haskell~
2. Presiona ~C-c C-c~
3. Â¡El cÃ³digo se ejecuta y ves el resultado!

*Nota*: Para que funcione, necesitas tener configurado ~ob-haskell~ en Doom Emacs (ya lo tienes si seguiste el setup).

-----

* Repo para practicar con los ejercicios del libro

*Libros principales*:
- [[http://www.cs.us.es/~jalonso/publicaciones/Piensa_en_Haskell.pdf][Piensa en Haskell]] (JosÃ© A. Alonso JimÃ©nez & Ma JosÃ© Hidalgo Doblado)
- [[http://learnyouahaskell.com/][Â¡Aprende Haskell por el Bien de Todos!]] / Learn You a Haskell for Great Good! (Miran LipovaÄa)

* MotivaciÃ³n y para quiÃ©n es Ãºtil esto

Este repo Ãºnicamente te va a servir de algo si eres un *noobskell* como yo, no tienes ni idea de cÃ³mo empezar, ni estÃ¡s en la uni con esos profesores autores del libro, pero andas con ganas de probar este lenguaje de programaciÃ³n puramente funcional y escapar de esa cÃ¡rcel de la PğŸ’©ğŸ’©

Este repo se crea para autodidactas, como el que lo escribe, con la intenciÃ³n de tener una pequeÃ±a referencia para los primeros pasos que hay que dar para aprender a programar en Haskell. A veces, precisamente lo mÃ¡s difÃ­cil es poder configurar un entorno de depuraciÃ³n amigable y familiarizarse con las herramientas necesarias para conseguir ejecutar algo.

La idea es dejar en este README los enlaces mÃ¡s interesantes que encuentre y mis propias anotaciones para usarlas como guÃ­a, principalmente para mÃ­, ya que creo que difÃ­cilmente estÃ© alguien mÃ¡s interesado. Si es asÃ­, hÃ¡zmelo saber con una â­ o un PR.

-----

* ğŸƒ Quick Start (5 minutos)

*Si ya tienes NixOS/Nix con flakes:*

#+begin_src bash
# 1. Clonar
git clone https://github.com/pascualmg/pensando-en-haskell
cd pensando-en-haskell

# 2. Activar entorno (solo primera vez)
direnv allow

# VerÃ¡s un mensaje bonito con las herramientas disponibles
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“ Entorno Haskell - Pensando en Haskell
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# GHC: 9.8.4
# Cabal: 3.16.0.0
# ...

# 3. Primera build (tarda un poco, descarga dependencias)
cabal update  # Solo primera vez
cabal build

# 4. Ejecutar
cabal run pensando-en-haskell-exe

# 5. Tests
cabal test

# âœ… Â¡YA ESTÃ! Ahora puedes empezar a programar
#+end_src

*Si no tienes Nix*, mira la secciÃ³n [[*ğŸš€ Setup desde cero (Nix + Doom Emacs)][Setup desde cero]] mÃ¡s abajo.

-----

* ğŸ® Ejemplos Interactivos (Â¡PruÃ©balos con C-c C-c!)

Estos ejemplos son ejecutables directamente en este README si lo abres con Doom Emacs:

** Ejemplo 1: Operaciones bÃ¡sicas

#+begin_src haskell
-- Suma simple
2 + 3
#+end_src

** Ejemplo 2: Funciones

#+begin_src haskell
-- Definir y usar una funciÃ³n
let suma3 x y z = x + y + z
in suma3 10 20 30
#+end_src

** Ejemplo 3: Listas y funciones de orden superior

#+begin_src haskell
-- Filtrar nÃºmeros pares y sumarlos
sum (filter even [1..10])
#+end_src

** Ejemplo 4: List comprehensions

#+begin_src haskell
-- Pares ordenados donde la suma es 10
[(x, y) | x <- [1..10], y <- [1..10], x + y == 10, x <= y]
#+end_src

** Ejemplo 5: RecursiÃ³n (factorial)

#+begin_src haskell
let factorial 0 = 1
    factorial n = n * factorial (n - 1)
in factorial 5
#+end_src

** Ejemplo 6: Tipos y polimorfismo

#+begin_src haskell
-- Longitud de diferentes tipos de listas
length [1, 2, 3, 4, 5]
#+end_src

#+begin_src haskell
length ["hola", "mundo", "haskell"]
#+end_src

** Ejemplo 7: Pattern matching

#+begin_src haskell
let describeLista [] = "Lista vacÃ­a"
    describeLista [x] = "Lista con un elemento: " ++ show x
    describeLista (x:y:_) = "Lista que empieza con " ++ show x ++ " y " ++ show y
in describeLista [1, 2, 3, 4]
#+end_src

*Nota*: Coloca el cursor en cualquier bloque y presiona ~C-c C-c~ para ejecutarlo. Â¡El resultado aparecerÃ¡ justo debajo!

-----

* ğŸ’» Desarrollo Diario (Lo que usarÃ¡s siempre)

** Comandos esenciales de Cabal

#+begin_src bash
# â•â•â• COMPILAR â•â•â•
cabal build                    # Compila todo el proyecto
cabal build pensando-en-haskell-exe  # Solo el ejecutable

# â•â•â• EJECUTAR â•â•â•
cabal run pensando-en-haskell-exe    # Compila (si hace falta) y ejecuta

# â•â•â• TESTS â•â•â•
cabal test                     # Ejecuta todos los tests (HSpec)
cabal test --test-show-details=direct  # Muestra output detallado

# â•â•â• REPL INTERACTIVO â•â•â•
cabal repl                     # GHCi con tu proyecto cargado
# Dentro del REPL:
# > :l src/MiModulo.hs          -- Cargar mÃ³dulo
# > :r                          -- Recargar cambios
# > :t miFuncion                -- Ver tipo
# > miFuncion argumentos         -- Ejecutar
# > :q                          -- Salir

# â•â•â• LIMPIAR â•â•â•
cabal clean                    # Borra builds (si algo va raro)
#+end_src

** Workflow real: AÃ±adiendo un ejercicio nuevo

*Ejemplo*: Vamos a aÃ±adir Ejercicio 14 del Tema 1

*1. Crear el mÃ³dulo* (~src/Exercises/Tema01/Ej14/MiEjercicio.hs~):

#+begin_src haskell
module Exercises.Tema01.Ej14.MiEjercicio (suma3) where

-- | Suma tres nÃºmeros
suma3 :: Int -> Int -> Int -> Int
suma3 x y z = x + y + z

-- >>> suma3 1 2 3
-- 6
#+end_src

*2. Crear el test* (~test/Exercises/Tema01/Ej14/MiEjercicioSpec.hs~):

#+begin_src haskell
module Exercises.Tema01.Ej14.MiEjercicioSpec (spec) where

import Test.Hspec
import Exercises.Tema01.Ej14.MiEjercicio

spec :: Spec
spec = describe "suma3" $ do
  it "suma tres nÃºmeros correctamente" $
    suma3 1 2 3 `shouldBe` 6
#+end_src

*3. Registrar en ~.cabal~* (~pensando-en-haskell.cabal~):

#+begin_src cabal
library
  exposed-modules:
      -- ... otros mÃ³dulos
      Exercises.Tema01.Ej14.MiEjercicio  -- â† AÃ±adir aquÃ­
#+end_src

Y en la secciÃ³n de tests:

#+begin_src cabal
test-suite pensando-en-haskell-test
  other-modules:
      -- ... otros tests
      Exercises.Tema01.Ej14.MiEjercicioSpec  -- â† AÃ±adir aquÃ­
#+end_src

*4. Compilar y probar*:

#+begin_src bash
cabal build  # DeberÃ­a compilar sin errores
cabal test   # Tu nuevo test deberÃ­a pasar
#+end_src

*5. Formatear* (opcional pero recomendado):

#+begin_src bash
fourmolu -i src/Exercises/Tema01/Ej14/MiEjercicio.hs
#+end_src

** ğŸ“¦ HOWTO: AÃ±adir una dependencia externa

*IMPORTANTE*: Este proyecto usa ~.cabal~ directamente (NO ~package.yaml~). Edita el archivo ~pensando-en-haskell.cabal~ manualmente.

*** Paso 1: Entender dÃ³nde aÃ±adir la dependencia

El ~.cabal~ tiene 3 secciones con ~build-depends~:

#+begin_example
library               â†’ CÃ³digo en src/
executable            â†’ CÃ³digo en app/ (Main.hs)
test-suite            â†’ Tests en test/
#+end_example

*Regla*: AÃ±ade la dependencia donde la vayas a usar.

*** Paso 2: Editar pensando-en-haskell.cabal

*Ejemplo real*: AÃ±adir ~http-conduit~ para hacer peticiones HTTP desde ~app/Main.hs~

Busca la secciÃ³n ~executable pensando-en-haskell-exe~ y aÃ±ade a ~build-depends~:

#+begin_src cabal
executable pensando-en-haskell-exe
  main-is: Main.hs
  hs-source-dirs: app
  ghc-options: -threaded -rtsopts -with-rtsopts=-N
  build-depends:
      base >=4.7 && <5
    , pensando-en-haskell
    , http-conduit        -- â† AÃ‘ADIR AQUÃ
#+end_src

*Tips*:
- Sin versiÃ³n â†’ Cabal elige la Ãºltima compatible automÃ¡ticamente
- Con versiÃ³n â†’ ~, http-conduit >= 2.3 && < 2.4~
- Usa comas al inicio (estilo ~, paquete~) para legibilidad

*** Paso 3: Compilar con direnv

*IMPORTANTE*: Ejecuta siempre dentro del entorno direnv:

#+begin_src bash
direnv exec . cabal build
# O si direnv ya estÃ¡ cargado en tu shell:
cabal build
#+end_src

Cabal descarga y compila la dependencia automÃ¡ticamente.

*** Paso 4: Recargar HLS en Emacs

HLS no detecta cambios en ~.cabal~ automÃ¡ticamente. ReinÃ­cialo:

#+begin_src emacs-lisp
M-x lsp-workspace-restart
# O el atajo:
SPC c R
#+end_src

Ahora HLS conoce la nueva dependencia â†’ autocompletado funciona.

*** Paso 5: Usar en tu cÃ³digo

#+begin_src haskell
-- En app/Main.hs
import Network.HTTP.Simple

main :: IO ()
main = do
  response <- httpBS "https://httpbin.org/get"
  print $ getResponseStatusCode response
#+end_src

*** Troubleshooting

*Error: ~Could not load module 'Network.HTTP.Simple'~*
â†’ La dependencia no estÃ¡ en el ~build-depends~ correcto. Verifica que estÃ© en la secciÃ³n donde usas el import (executable, library o test).

*Error: ~Missing C library: z~*
â†’ Falta una librerÃ­a del sistema. AÃ±Ã¡dela a ~flake.nix~ en ~System dependencies~ y ejecuta ~direnv reload~.

*** Resumen rÃ¡pido

#+begin_src bash
# 1. Editar pensando-en-haskell.cabal (aÃ±adir a build-depends)
# 2. Compilar
direnv exec . cabal build
# 3. Recargar HLS en Emacs
M-x lsp-workspace-restart
#+end_src

** Desarrollo rÃ¡pido con ghcid

*ghcid* recompila automÃ¡ticamente cuando guardas archivos. Es MÃGICO.

#+begin_src bash
# En una terminal aparte (dejar corriendo)
ghcid --command='cabal repl'

# Ahora edita cualquier archivo .hs
# ghcid recompila en < 1 segundo y muestra errores
# Â¡Feedback instantÃ¡neo!
#+end_src

En Doom Emacs, ghcid + HLS es imparable:
- *ghcid*: Feedback rÃ¡pido en terminal
- *HLS*: Errores inline, autocompletado, goto definition

-----

* ğŸ”§ Herramientas disponibles

Cuando entras al proyecto con ~direnv~, tienes todo esto automÃ¡ticamente en el PATH:

** Core Toolchain
- *GHC 9.8.4* - Compilador Haskell
- *cabal-install 3.16* - Build tool (lo que usamos)
- *haskell-language-server* - LSP para IDE (Doom Emacs)

** ğŸ¨ Formatters (hacer cÃ³digo bonito)

*** fourmolu â­ (recomendado)

Fork configurable de ormolu. Usa =fourmolu.yaml= del proyecto.

#+begin_src bash
# Formatear UN archivo
fourmolu -i src/Exercises/Tema01/Ej01/MediaDeTresNumeros.hs

# Formatear TODO el proyecto
fourmolu -i $(find src test app -name "*.hs")

# Ver quÃ© cambiarÃ­a SIN modificar (dry-run)
fourmolu src/MiModulo.hs

# Formatear solo archivos modificados (git)
git diff --name-only | grep ".hs$" | xargs fourmolu -i
#+end_src

*En Doom Emacs*: ~SPC c f~ formatea automÃ¡ticamente con fourmolu (ya configurado).

*** ormolu (alternativa)

MÃ¡s opinionado, sin configuraciÃ³n posible.

#+begin_src bash
ormolu -i src/MiModulo.hs
#+end_src

*** Personalizar fourmolu

Edita =fourmolu.yaml= en la raÃ­z del proyecto:

#+begin_src yaml
indentation: 2              # Espacios de indentaciÃ³n
comma-style: leading        # Comas al principio en listas
diff-friendly-import-export: true
respectful: true            # No reformatear TODO agresivamente
#+end_src

** ğŸ” Linting (sugerencias de mejora)

*** hlint

Sugiere mejoras de estilo, funciones mÃ¡s idiomÃ¡ticas, y optimizaciones.

#+begin_src bash
# Ver todas las sugerencias del proyecto
hlint src/ test/ app/

# Ver sugerencias de UN archivo
hlint src/Exercises/Tema01/Ej02/SumaEurosColeccionMonedas.hs

# Aplicar sugerencias automÃ¡ticamente (CUIDADO: revisa despuÃ©s)
hlint src/ --refactor --refactor-options="-i"

# Generar reporte HTML
hlint src/ --report=hlint-report.html

# Ignorar ciertas sugerencias
hlint src/ --ignore="Use camelCase"
#+end_src

*Ejemplo de output*:

#+begin_example
src/Lib.hs:23:1: Suggestion: Use newtype instead of data
Found:
  data Wrapper = Wrapper Int
Why not:
  newtype Wrapper = Wrapper Int
#+end_example

*En Doom Emacs*: ~SPC c a~ te muestra code actions de hlint integradas con LSP.

** ğŸš€ Desarrollo RÃ¡pido

*** ghcid (recompilaciÃ³n automÃ¡tica instantÃ¡nea)

Recompila tu cÃ³digo cada vez que guardas un archivo. *SÃšPER RÃPIDO*.

#+begin_src bash
# Monitorear todo el proyecto
ghcid --command='cabal repl'

# Monitorear solo tests
ghcid --command='cabal repl pensando-en-haskell-test'

# Monitorear Y ejecutar un comando al compilar OK
ghcid --command='cabal repl' --test='main'

# Con colores bonitos
ghcid --command='cabal repl' --color=always
#+end_src

*Tip*: Deja ghcid corriendo en una terminal mientras programas. VerÃ¡s errores al instante.

#+begin_example
All good (8 modules, at 14:32:05)

# Guardas archivo con error...

src/Lib.hs:23:5: error:
    â€¢ Couldn't match expected type 'Int' with actual type 'String'
    â€¢ In the expression: "hola"

# Lo arreglas y guardas...

All good (8 modules, at 14:32:12)
#+end_example

*** hoogle (buscar funciones por nombre o tipo)

Busca funciones, tipos, mÃ³dulos en toda la documentaciÃ³n de Haskell.

#+begin_src bash
# Buscar por nombre
hoogle "map"
hoogle "sort"

# Buscar por TIPO (lo mÃ¡s Ãºtil)
hoogle "(a -> b) -> [a] -> [b]"
# â†’ Devuelve: map :: (a -> b) -> [a] -> [b]

hoogle "[a] -> Int"
# â†’ Devuelve: length, sum, product...

hoogle "Ord a => [a] -> [a]"
# â†’ Devuelve: sort, nub, group...

# Buscar en un paquete especÃ­fico
hoogle "decode" +aeson

# Ver documentaciÃ³n completa
hoogle "map" --info
#+end_src

*Online*: TambiÃ©n disponible en https://hoogle.haskell.org/

*En Doom Emacs*: Puedes configurar un keybinding para hoogle (ver secciÃ³n Doom Emacs).

*** gen-hie (regenerar configuraciÃ³n HLS)

Si aÃ±ades nuevos componentes al =.cabal= (por ejemplo, un segundo ejecutable), regenera =hie.yaml=:

#+begin_src bash
# Regenerar hie.yaml automÃ¡ticamente
gen-hie > hie.yaml

# Ver quÃ© generarÃ­a SIN escribir archivo
gen-hie
#+end_src

Luego reinicia LSP en Emacs: ~M-x lsp-workspace-restart~

** ğŸ“¦ Herramientas del sistema (incluidas en flake)

*** zlib, gmp, pkg-config

LibrerÃ­as C necesarias para compilar ciertos paquetes de Haskell.

Ya estÃ¡n incluidas en =flake.nix=, no necesitas hacer nada.

** ğŸ¯ Workflow completo con todas las herramientas

*** Antes de commitear:

#+begin_src bash
# 1. Formatear todo
fourmolu -i $(git diff --name-only --cached | grep ".hs$")

# 2. Ver sugerencias de hlint
hlint src/ test/ app/

# 3. Compilar
cabal build

# 4. Tests
cabal test

# 5. Todo OK? Commit!
git commit
#+end_src

*** Durante el desarrollo:

#+begin_example
Terminal 1: ghcid --command='cabal repl'  # Auto-recompilaciÃ³n
Terminal 2: cabal test --test-show-details=streaming  # Tests
Emacs: Escribiendo cÃ³digo con LSP activo
#+end_example

** ğŸ› ï¸ AÃ±adir mÃ¡s herramientas al flake

Si quieres aÃ±adir una herramienta nueva (ejemplo: =stan= para anÃ¡lisis estÃ¡tico):

1. Edita =flake.nix=:

#+begin_src nix
packages = with hsPkgs; [
  ghc
  cabal-install
  # ... otras herramientas
  stan  # â† AÃ±adir aquÃ­
] ++ (with pkgs; [
  # ...
]);
#+end_src

2. Recarga direnv:

#+begin_src bash
direnv reload
#+end_src

3. Verifica:

#+begin_src bash
which stan  # DeberÃ­a mostrar el path en /nix/store/...
#+end_src

-----

* ğŸ¯ Doom Emacs: GuÃ­a Completa de Comandos

** Lo esencial (memoriza estos 5)

| Keybinding | DescripciÃ³n                     | Uso                           |
|------------+---------------------------------+-------------------------------|
| ~K~        | Ver tipo y documentaciÃ³n        | â­ EL MÃS ÃšTIL - Ãºsalo siempre |
| ~gd~       | Ir a definiciÃ³n                 | Navegar cÃ³digo                |
| ~SPC c a~  | Code actions (imports, fixes)   | Arreglar errores automÃ¡tico   |
| ~SPC c f~  | Formatear con fourmolu          | Antes de commitear            |
| ~] d~      | Siguiente error                 | Revisar errores uno por uno   |

** NavegaciÃ³n de CÃ³digo

| Keybinding | Comando                   | DescripciÃ³n                         |
|------------+---------------------------+-------------------------------------|
| ~K~        | ~lsp-describe-thing-at-point~ | Ver tipo y documentaciÃ³n            |
| ~gd~       | ~+lookup/definition~      | Ir a definiciÃ³n                     |
| ~gD~       | ~+lookup/declaration~     | Ir a declaraciÃ³n                    |
| ~gr~       | ~+lookup/references~      | Ver todas las referencias           |
| ~C-o~      | ~evil-jump-backward~      | Volver atrÃ¡s en historial de saltos |
| ~C-i~      | ~evil-jump-forward~       | Avanzar en historial                |

** Code Actions y Refactoring (~SPC c~)

| Keybinding | Comando              | DescripciÃ³n                        |
|------------+----------------------+------------------------------------|
| ~SPC c a~  | ~lsp-execute-code-action~ | Auto-imports, fixes automÃ¡ticos    |
| ~SPC c r~  | ~lsp-rename~         | Renombrar sÃ­mbolo en todo proyecto |
| ~SPC c f~  | ~+format/buffer~     | Formatear buffer con fourmolu      |
| ~SPC c k~  | ~+lookup/documentation~ | Ver documentaciÃ³n completa         |
| ~SPC c d~  | ~+lookup/definition~ | Ir a definiciÃ³n (igual que gd)     |
| ~SPC c D~  | ~+lookup/references~ | Ver referencias (igual que gr)     |

** Errores y DiagnÃ³sticos

| Keybinding | Comando              | DescripciÃ³n                   |
|------------+----------------------+-------------------------------|
| ~] d~      | ~flycheck-next-error~    | Siguiente error/warning       |
| ~[ d~      | ~flycheck-previous-error~ | Error/warning anterior        |
| ~SPC c x~  | ~flycheck-list-errors~   | Lista errores del buffer      |
| ~SPC c X~  | ~lsp-treemacs-errors-list~ | Lista errores del proyecto    |

** BÃºsqueda (~SPC s~)

| Keybinding | Comando                 | DescripciÃ³n                  |
|------------+-------------------------+------------------------------|
| ~SPC s s~  | ~+default/search-buffer~  | Buscar en buffer actual      |
| ~SPC s p~  | ~+default/search-project~ | Buscar en todo el proyecto   |
| ~SPC s i~  | ~lsp-ui-imenu~          | Buscar sÃ­mbolos (funciones)  |

** Proyecto (~SPC p~)

| Keybinding | Comando               | DescripciÃ³n          |
|------------+-----------------------+----------------------|
| ~SPC p p~  | ~projectile-switch-project~ | Cambiar de proyecto  |
| ~SPC p f~  | ~projectile-find-file~      | Buscar archivo       |
| ~SPC p c~  | ~projectile-compile-project~ | Compilar proyecto    |
| ~SPC p t~  | ~projectile-test-project~   | Ejecutar tests       |

** REPL (GHCi)

| Comando                         | DescripciÃ³n                   |
|---------------------------------+-------------------------------|
| ~M-x run-haskell~               | Abrir REPL de Haskell (GHCi)  |
| ~M-x haskell-process-load-file~ | Cargar archivo actual en REPL |

Dentro del REPL:
#+begin_src haskell
:l Main              -- Cargar mÃ³dulo Main
:r                   -- Recargar mÃ³dulo actual
:t expresion         -- Ver tipo de expresiÃ³n
:i nombre            -- Ver info sobre funciÃ³n/tipo
:q                   -- Salir del REPL
#+end_src

** Workflows PrÃ¡cticos

*** Workflow 1: Explorando cÃ³digo existente

#+begin_example
1. SPC p f â†’ Abro archivo
2. Veo una funciÃ³n interesante
3. K sobre ella â†’ veo su tipo
4. gd â†’ salto a su definiciÃ³n
5. gr â†’ veo dÃ³nde se usa
6. C-o â†’ vuelvo donde estaba
#+end_example

*** Workflow 2: Escribiendo cÃ³digo nuevo

#+begin_example
1. Empiezo a escribir una funciÃ³n
2. Autocompletado me sugiere
3. LSP muestra errores en rojo
4. SPC c a â†’ imports automÃ¡ticos
5. SPC c f â†’ formateo
6. :w â†’ guardo
#+end_example

*** Workflow 3: Debugging un error

#+begin_example
1. Veo error en rojo
2. Hover sobre Ã©l â†’ leo mensaje
3. ] d â†’ siguiente error
4. SPC c a â†’ fix automÃ¡tico
5. Si no, corrijo manual
6. SPC c f â†’ formateo
7. Verifico que desaparece
#+end_example

*** Workflow 4: Refactoring

#+begin_example
1. Quiero renombrar funciÃ³n
2. Cursor sobre el nombre
3. SPC c r â†’ rename
4. Escribo nuevo nombre
5. Enter â†’ cambia en TODO el proyecto
6. SPC p c â†’ compilo para verificar
#+end_example

** Lo que HLS te da automÃ¡ticamente

- âœ… Errores de tipos inline
- âœ… Autocompletado inteligente
- âœ… Hover para ver tipos
- âœ… Refactorings automÃ¡ticos
- âœ… Aplicar sugerencias de hlint
- âœ… Auto-imports
- âœ… Formateo con fourmolu

** Debugging LSP

| Comando                    | DescripciÃ³n                    |
|----------------------------+--------------------------------|
| ~M-x lsp-describe-session~ | Ver sesiÃ³n LSP activa          |
| ~M-x lsp-workspace-restart~ | Reiniciar LSP                  |
| ~M-x lsp-doctor~           | Diagnosticar problemas con LSP |
| ~SPC h l~                  | Ver buffer ~*Messages*~        |

** ConfiguraciÃ³n actual (minimalista)

Tu config en =~/.config/doom/config.el= solo tiene esto:

#+begin_src elisp
;; ConfiguraciÃ³n mÃ­nima: Doom maneja todo con +lsp +tree-sitter
(after! lsp-haskell
  (setq lsp-haskell-formatting-provider "fourmolu"))
#+end_src

Todo lo demÃ¡s funciona automÃ¡ticamente con:
- ~(haskell +lsp +tree-sitter +test)~ en =init.el=
- direnv + flake.nix del proyecto

-----

* ğŸš€ Setup desde cero (Nix + Doom Emacs)

Si no tienes nada instalado, aquÃ­ estÃ¡ el setup completo.

** Prerrequisitos

1. *NixOS* o *Nix* con flakes habilitado
2. *Home Manager* configurado
3. *Doom Emacs* instalado
4. *direnv* + *nix-direnv* habilitado en home-manager

** ConfiguraciÃ³n en home-manager

Las herramientas Haskell ya estÃ¡n en =~/dotfiles/home-manager/.config/home-manager/home.nix=:

#+begin_src nix
home.packages = with pkgs; [
  # Core
  haskellPackages.ghc
  haskell-language-server  # Top-level package (wrapper multi-GHC)
  haskellPackages.cabal-install

  # Formatters
  haskellPackages.fourmolu
  haskellPackages.ormolu

  # Linting
  haskellPackages.hlint

  # Development
  haskellPackages.ghcid
  haskellPackages.hoogle
  haskellPackages.implicit-hie

  # System deps
  gmp
  zlib
  gcc
];
#+end_src

Aplicar cambios:

#+begin_src bash
home-manager switch
doom sync  # Si usas Doom Emacs
#+end_src

** ConfiguraciÃ³n de Doom Emacs

En =~/.doom.d/init.el=:

#+begin_src elisp
(doom!
  :tools
  lsp
  direnv
  tree-sitter

  :lang
  (haskell +lsp +test +tree-sitter))
#+end_src

En =~/.doom.d/config.el=:

#+begin_src elisp
;; PATH para herramientas Nix (ya configurado)
(add-to-list 'exec-path (expand-file-name "~/.nix-profile/bin"))

;; IMPORTANTE: Activar envrc globalmente para direnv
(after! envrc
  (envrc-global-mode +1))

;; Habilitar LSP con lsp-deferred (NO lsp directo)
(add-hook 'haskell-mode-hook #'lsp-deferred)
(add-hook 'haskell-literate-mode-hook #'lsp-deferred)

;; LSP con HLS + fourmolu
(after! lsp-haskell
  (setq lsp-haskell-server-path "haskell-language-server-wrapper")
  (setq lsp-haskell-formatting-provider "fourmolu")

  ;; Habilitar plugin eval para -- >>> comments
  (setq lsp-haskell-plugin-eval-on t))
#+end_src

*Importante*: DespuÃ©s de modificar la config:

#+begin_src bash
doom sync    # Sincronizar paquetes
doom reload  # O reiniciar Emacs
#+end_src

-----

* ğŸ“š Estructura del Proyecto

#+begin_example
pensando-en-haskell/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ Exercises/
â”‚   â”‚   â””â”€â”€ Tema01/           # Ejercicios del libro organizados por tema
â”‚   â”‚       â”œâ”€â”€ Ej01/
â”‚   â”‚       â”œâ”€â”€ Ej02/
â”‚   â”‚       â””â”€â”€ ...
â”‚   â”œâ”€â”€ ADNCalculator.hs      # Ejemplos varios
â”‚   â””â”€â”€ Lib.hs
â”œâ”€â”€ test/                      # Tests con HSpec
â”‚   â”œâ”€â”€ Exercises/
â”‚   â””â”€â”€ Spec.hs               # Entry point de tests
â”œâ”€â”€ app/
â”‚   â””â”€â”€ Main.hs               # Ejecutable principal
â”œâ”€â”€ flake.nix                 # âš™ï¸  Entorno de desarrollo Nix
â”œâ”€â”€ hie.yaml                  # ğŸ”§ Config HLS (estructura proyecto)
â”œâ”€â”€ fourmolu.yaml             # ğŸ¨ Estilo de formateo
â”œâ”€â”€ .envrc                    # ğŸ”„ ActivaciÃ³n automÃ¡tica direnv
â””â”€â”€ pensando-en-haskell.cabal # ğŸ“¦ DefiniciÃ³n del proyecto
#+end_example

-----

* ğŸ› Troubleshooting

** ~direnv: error .envrc is blocked~

#+begin_src bash
# Permitir direnv explÃ­citamente
direnv allow
#+end_src

** HLS no arranca en Doom Emacs

#+begin_src bash
# Verificar que HLS estÃ¡ en PATH
which haskell-language-server-wrapper

# DeberÃ­a mostrar: /home/tu-user/.nix-profile/bin/haskell-language-server-wrapper
#+end_src

En Emacs:
#+begin_example
M-x lsp-workspace-show-log  # Ver logs de LSP
M-x lsp-describe-session    # Ver estado de la sesiÃ³n
#+end_example

** ~GHC ABIs don't match!~ (IMPORTANTE)

Si ves este error:
#+begin_example
GHC ABIs don't match!
Expected: ghc-9.8.4:XXXXXXX
Got:      ghc-9.8.4:YYYYYYY
#+end_example

*Causa*: HLS fue compilado con una versiÃ³n de GHC diferente (aunque sea el mismo nÃºmero de versiÃ³n).

*SoluciÃ³n*:

1. *NUNCA* instalar HLS globalmente en home-manager si usas diferentes versiones de nixpkgs entre el sistema y los proyectos.

2. El flake *DEBE* usar ~nixos-25.05~ (stable) NO ~nixos-unstable~:

#+begin_src nix
inputs = {
  nixpkgs.url = "github:NixOS/nixpkgs/nixos-25.05";  # â† Importante
  flake-utils.url = "github:numtide/flake-utils";
};
#+end_src

3. HLS debe venir del ~pkgs~ top-level del flake:

#+begin_src nix
] ++ (with pkgs; [
  haskell-language-server  # â† Del mismo nixpkgs que GHC
#+end_src

*NO* usar ~hsPkgs.haskell-language-server~ (compilarÃ­a desde source y fallarÃ­a).

4. Asegurar que direnv/envrc estÃ¡ cargando el environment:

#+begin_src bash
# En el directorio del proyecto
direnv reload

# Verificar que cargÃ³
echo $IN_NIX_SHELL  # DeberÃ­a mostrar: impure
#+end_src

5. Reiniciar el daemon de Emacs completamente:

#+begin_src bash
emacsclient -e '(kill-emacs)'
# Esperar un momento
emacsclient -nw ~/src/pensando-en-haskell
#+end_src

** ~cabal: Could not resolve dependencies~

Significa que las versiones en ~build-depends~ no son compatibles.

*SoluciÃ³n 1*: Dejar que Cabal elija versiones automÃ¡ticamente:

#+begin_src cabal
build-depends: base >=4.7 && <5
             , text  -- Sin especificar versiÃ³n
#+end_src

*SoluciÃ³n 2*: Ver quÃ© versiÃ³n funciona:

#+begin_src bash
cabal build --allow-newer  # Permite versiones mÃ¡s nuevas
#+end_src

** Build muy lento la primera vez

*Normal*. La primera build descarga y compila dependencias (aeson, hspec, etc.). Las siguientes builds son rÃ¡pidas porque Cabal cachea todo.

#+begin_src bash
# Primera vez
cabal build  # ~2-5 minutos

# Siguientes veces
cabal build  # ~5-20 segundos (solo recompila cambios)
#+end_src

** ~git tree is dirty~ warning de direnv

Es solo un warning, no afecta. Significa que hay cambios sin commitear.

-----

* ğŸ“– Recursos de Aprendizaje

** Libros (ordenados por dificultad)

1. [[http://www.cs.us.es/~jalonso/publicaciones/Piensa_en_Haskell.pdf][Piensa en Haskell]] â­ - El libro de este repo (EN ESPAÃ‘OL)
2. [[http://learnyouahaskell.com/][Learn You a Haskell]] - Divertido, ilustrado, para empezar
3. [[https://haskellbook.com/][Haskell Programming from First Principles]] - El mÃ¡s completo (de pago)

** Cursos y Tutoriales

- [[https://github.com/haskell-beginners-2022/course-plan][Haskell Beginners 2022 Course]] - Curso completo gratis
- [[https://typeclasses.com/beginner-crash-course/types-and-functions-1][Type Classes - Beginner Crash Course]]
- [[https://www.fpcomplete.com/haskell/tutorial/][FP Complete - Haskell Tutorial]]

** Referencias RÃ¡pidas

- [[https://hoogle.haskell.org/][Hoogle]] - Busca funciones por nombre o tipo
- [[https://hackage.haskell.org/][Hackage]] - Repositorio de paquetes Haskell
- [[https://cheatsheet.codeslower.com/CheatSheet.pdf][Haskell Cheatsheet]]

-----

* ğŸ”§ Archivos de ConfiguraciÃ³n Explicados

** ~flake.nix~ - Entorno de desarrollo

Define quÃ© herramientas estÃ¡n disponibles en el proyecto. Usa *nixpkgs haskellPackages* (enfoque estÃ¡ndar Nix).

#+begin_src nix
{
  description = "Entorno Haskell con GHC 9.8";

  # GHC, cabal, fourmolu, hlint, ghcid, etc.
  # Se activan automÃ¡ticamente con direnv
}
#+end_src

*No necesitas tocarlo* a menos que quieras cambiar versiÃ³n de GHC o aÃ±adir herramientas del sistema.

** ~hie.yaml~ - ConfiguraciÃ³n HLS

Le dice a HLS cÃ³mo estÃ¡ estructurado tu proyecto (lib, exe, test).

#+begin_src yaml
cradle:
  cabal:
    - path: "./src"
      component: "lib:pensando-en-haskell"
    - path: "./test"
      component: "pensando-en-haskell:test:pensando-en-haskell-test"
#+end_src

*Regenerar si aÃ±ades componentes nuevos*:

#+begin_src bash
gen-hie > hie.yaml
#+end_src

** ~fourmolu.yaml~ - Estilo de cÃ³digo

ConfiguraciÃ³n del formateador (indentaciÃ³n, imports, etc.).

#+begin_src yaml
indentation: 2
comma-style: leading
diff-friendly-import-export: true
#+end_src

*Personalizar* segÃºn preferencias del equipo.

** ~pensando-en-haskell.cabal~ - DefiniciÃ³n del proyecto

El archivo mÃ¡s importante. Define:
- QuÃ© mÃ³dulos expone tu librerÃ­a (~exposed-modules~)
- Dependencias externas (~build-depends~)
- Ejecutables y tests

*Este sÃ­ lo editarÃ¡s* constantemente al aÃ±adir mÃ³dulos y dependencias.

-----

* ğŸ¤“ ApÃ©ndice: Por quÃ© este setup tÃ©cnico

** TL;DR: nixpkgs es suficiente para aprender

Este proyecto usa *nixpkgs haskellPackages*, el enfoque estÃ¡ndar de Nix para Haskell.

*Â¿Por quÃ© no Stack?*
- Stack y Nix juntos son incÃ³modos (ambos gestionan dependencias)
- Cabal es mÃ¡s simple y se integra mejor con Nix

*Â¿Por quÃ© no haskell.nix?*
- MÃ¡s complejo (IFD, materializaciÃ³n, cache propio)
- Overkill para aprender Haskell
- haskell.nix es para cross-compilation y proyectos industriales

*Â¿Por quÃ© no haskell-flake?*
- Es buena opciÃ³n, pero aÃ±ade abstracciÃ³n extra
- Para este proyecto educativo, nixpkgs raw es suficiente y mÃ¡s directo

** ComparaciÃ³n rÃ¡pida de enfoques Nix+Haskell

| Enfoque              | Complejidad | Mejor para                   | Flexibilidad |
|----------------------+-------------+------------------------------+--------------|
| *nixpkgs* â­         | Baja        | Proyectos estÃ¡ndar, aprender | Media        |
| *haskell-flake*      | Media       | Equipos, monorepos           | Media        |
| *haskell.nix*        | Alta        | Cross-compilation, industria | MÃ¡xima       |

*Para aprender Haskell*: nixpkgs es perfecto. Simple, cacheado, reproducible.

*Para producciÃ³n/empresa*: Considera haskell-flake o haskell.nix segÃºn necesidades.

** Trade-off: Consistencia vs Libertad

*nixpkgs*: Un conjunto consistente de paquetes (como una distribuciÃ³n Linux)
- âœ… Todo funciona junto sin conflictos
- âœ… Cache binario excelente (builds rÃ¡pidos)
- âŒ Solo versiones del snapshot (actualmente GHC 9.8)
- âŒ Ignora restricciones de versiÃ³n de Cabal

*haskell.nix*: Libertad total (como compilar todo desde source)
- âœ… Cualquier versiÃ³n de cualquier paquete
- âœ… Respeta restricciones exactas de Cabal
- âŒ MÃ¡s complejo (IFD, materializaciÃ³n)
- âŒ Cache menos completo

*Este proyecto*: nixpkgs es suficiente porque:
1. No necesitamos versiones especÃ­ficas raras
2. Aprendiendo Haskell, no manteniendo software crÃ­tico
3. Queremos setup simple que funcione

Si algÃºn dÃ­a necesitas haskell.nix, la migraciÃ³n es posible (pero este README ya serÃ­a otro).

-----

* ğŸ“ FilosofÃ­a del Repo

*Objetivo*: Bajar la barrera de entrada a Haskell.

La configuraciÃ³n de entorno en Haskell puede ser frustrante. Este repo ofrece:
- âœ… Setup que funciona out-of-the-box
- âœ… Ejemplos reales de ejercicios
- âœ… Tests como documentaciÃ³n
- âœ… Herramientas modernas (HLS, ghcid, formatters)

*No es*: Un template perfecto para producciÃ³n.

*Es*: Un entorno cÃ³modo para aprender sin pelear con tooling.

-----

* ğŸ¤ Contribuir

Â¿Encontraste un error? Â¿MejorarÃ­as algo? *Â¡PR bienvenidos!*

Ãreas donde ayuda serÃ­a genial:
- MÃ¡s ejercicios resueltos con tests
- Explicaciones en espaÃ±ol de conceptos difÃ­ciles
- Mejoras al README (siempre se puede mejorar)
- Alternativas de setup mÃ¡s simples

-----

* ğŸ“œ Licencia

MIT - Haz lo que quieras con este cÃ³digo.

-----

*Â¡Feliz Haskelling! ğŸš€*

Si este repo te sirviÃ³, dale una â­ para que otros noobskells lo encuentren.
