#+TITLE: Pensando en Haskell
#+AUTHOR: pascualmg
#+DATE: 2025
#+OPTIONS: toc:2 num:nil
#+PROPERTY: header-args:haskell :results value :exports both

#+begin_quote
âš ï¸ *IMPORTANTE*: Este proyecto usa ~nixos-25.05~ (stable) NO ~nixos-unstable~.

RazÃ³n: Compatibilidad entre HLS y GHC 9.8.4. Ver secciÃ³n [[*~GHC ABIs don't match!~ (IMPORTANTE)][Troubleshooting â†’ GHC ABIs don't match]].
#+end_quote

* README Interactivo ğŸ®

Este README estÃ¡ en formato Org-mode, lo que significa que los snippets de cÃ³digo Haskell son *ejecutables* directamente en Emacs:

1. Coloca el cursor en cualquier bloque ~#+begin_src haskell~
2. Presiona ~C-c C-c~
3. Â¡El cÃ³digo se ejecuta y ves el resultado!

*Nota*: Para que funcione, necesitas tener configurado ~ob-haskell~ en Doom Emacs (ya lo tienes si seguiste el setup).

-----

* Repo para practicar con los ejercicios del libro

*Libros principales*:
- [[http://www.cs.us.es/~jalonso/publicaciones/Piensa_en_Haskell.pdf][Piensa en Haskell]] (JosÃ© A. Alonso JimÃ©nez & Ma JosÃ© Hidalgo Doblado)
- [[http://learnyouahaskell.com/][Â¡Aprende Haskell por el Bien de Todos!]] / Learn You a Haskell for Great Good! (Miran LipovaÄa)

* MotivaciÃ³n y para quiÃ©n es Ãºtil esto

Este repo Ãºnicamente te va a servir de algo si eres un *noobskell* como yo, no tienes ni idea de cÃ³mo empezar, ni estÃ¡s en la uni con esos profesores autores del libro, pero andas con ganas de probar este lenguaje de programaciÃ³n puramente funcional y escapar de esa cÃ¡rcel de la PğŸ’©ğŸ’©

Este repo se crea para autodidactas, como el que lo escribe, con la intenciÃ³n de tener una pequeÃ±a referencia para los primeros pasos que hay que dar para aprender a programar en Haskell. A veces, precisamente lo mÃ¡s difÃ­cil es poder configurar un entorno de depuraciÃ³n amigable y familiarizarse con las herramientas necesarias para conseguir ejecutar algo.

La idea es dejar en este README los enlaces mÃ¡s interesantes que encuentre y mis propias anotaciones para usarlas como guÃ­a, principalmente para mÃ­, ya que creo que difÃ­cilmente estÃ© alguien mÃ¡s interesado. Si es asÃ­, hÃ¡zmelo saber con una â­ o un PR.

-----

* ğŸƒ Quick Start (5 minutos)

*Si ya tienes NixOS/Nix con flakes:*

#+begin_src bash
# 1. Clonar
git clone https://github.com/pascualmg/pensando-en-haskell
cd pensando-en-haskell

# 2. Activar entorno (solo primera vez)
direnv allow

# VerÃ¡s un mensaje bonito con las herramientas disponibles
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“ Entorno Haskell - Pensando en Haskell
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# GHC: 9.8.4
# Cabal: 3.16.0.0
# ...

# 3. Primera build (tarda un poco, descarga dependencias)
cabal update  # Solo primera vez
cabal build

# 4. Ejecutar
cabal run pensando-en-haskell-exe

# 5. Tests
cabal test

# âœ… Â¡YA ESTÃ! Ahora puedes empezar a programar
#+end_src

*Si no tienes Nix*, mira la secciÃ³n [[*ğŸš€ Setup desde cero (Nix + Doom Emacs)][Setup desde cero]] mÃ¡s abajo.

-----

* ğŸ® Ejemplos Interactivos (Â¡PruÃ©balos con C-c C-c!)

Estos ejemplos son ejecutables directamente en este README si lo abres con Doom Emacs:

** Ejemplo 1: Operaciones bÃ¡sicas

#+begin_src haskell
-- Suma simple
2 + 3
#+end_src

** Ejemplo 2: Funciones

#+begin_src haskell
-- Definir y usar una funciÃ³n
let suma3 x y z = x + y + z
in suma3 10 20 30
#+end_src

** Ejemplo 3: Listas y funciones de orden superior

#+begin_src haskell
-- Filtrar nÃºmeros pares y sumarlos
sum (filter even [1..10])
#+end_src

** Ejemplo 4: List comprehensions

#+begin_src haskell
-- Pares ordenados donde la suma es 10
[(x, y) | x <- [1..10], y <- [1..10], x + y == 10, x <= y]
#+end_src

** Ejemplo 5: RecursiÃ³n (factorial)

#+begin_src haskell
let factorial 0 = 1
    factorial n = n * factorial (n - 1)
in factorial 5
#+end_src

** Ejemplo 6: Tipos y polimorfismo

#+begin_src haskell
-- Longitud de diferentes tipos de listas
length [1, 2, 3, 4, 5]
#+end_src

#+begin_src haskell
length ["hola", "mundo", "haskell"]
#+end_src

** Ejemplo 7: Pattern matching

#+begin_src haskell
let describeLista [] = "Lista vacÃ­a"
    describeLista [x] = "Lista con un elemento: " ++ show x
    describeLista (x:y:_) = "Lista que empieza con " ++ show x ++ " y " ++ show y
in describeLista [1, 2, 3, 4]
#+end_src

*Nota*: Coloca el cursor en cualquier bloque y presiona ~C-c C-c~ para ejecutarlo. Â¡El resultado aparecerÃ¡ justo debajo!

-----

* ğŸ’» Desarrollo Diario (Lo que usarÃ¡s siempre)

** Comandos esenciales de Cabal

#+begin_src bash
# â•â•â• COMPILAR â•â•â•
cabal build                    # Compila todo el proyecto
cabal build pensando-en-haskell-exe  # Solo el ejecutable

# â•â•â• EJECUTAR â•â•â•
cabal run pensando-en-haskell-exe    # Compila (si hace falta) y ejecuta

# â•â•â• TESTS â•â•â•
cabal test                     # Ejecuta todos los tests (HSpec)
cabal test --test-show-details=direct  # Muestra output detallado

# â•â•â• REPL INTERACTIVO â•â•â•
cabal repl                     # GHCi con tu proyecto cargado
# Dentro del REPL:
# > :l src/MiModulo.hs          -- Cargar mÃ³dulo
# > :r                          -- Recargar cambios
# > :t miFuncion                -- Ver tipo
# > miFuncion argumentos         -- Ejecutar
# > :q                          -- Salir

# â•â•â• LIMPIAR â•â•â•
cabal clean                    # Borra builds (si algo va raro)
#+end_src

** Workflow real: AÃ±adiendo un ejercicio nuevo

*Ejemplo*: Vamos a aÃ±adir Ejercicio 14 del Tema 1

*1. Crear el mÃ³dulo* (~src/Exercises/Tema01/Ej14/MiEjercicio.hs~):

#+begin_src haskell
module Exercises.Tema01.Ej14.MiEjercicio (suma3) where

-- | Suma tres nÃºmeros
suma3 :: Int -> Int -> Int -> Int
suma3 x y z = x + y + z

-- >>> suma3 1 2 3
-- 6
#+end_src

*2. Crear el test* (~test/Exercises/Tema01/Ej14/MiEjercicioSpec.hs~):

#+begin_src haskell
module Exercises.Tema01.Ej14.MiEjercicioSpec (spec) where

import Test.Hspec
import Exercises.Tema01.Ej14.MiEjercicio

spec :: Spec
spec = describe "suma3" $ do
  it "suma tres nÃºmeros correctamente" $
    suma3 1 2 3 `shouldBe` 6
#+end_src

*3. Registrar en ~.cabal~* (~pensando-en-haskell.cabal~):

#+begin_src cabal
library
  exposed-modules:
      -- ... otros mÃ³dulos
      Exercises.Tema01.Ej14.MiEjercicio  -- â† AÃ±adir aquÃ­
#+end_src

Y en la secciÃ³n de tests:

#+begin_src cabal
test-suite pensando-en-haskell-test
  other-modules:
      -- ... otros tests
      Exercises.Tema01.Ej14.MiEjercicioSpec  -- â† AÃ±adir aquÃ­
#+end_src

*4. Compilar y probar*:

#+begin_src bash
cabal build  # DeberÃ­a compilar sin errores
cabal test   # Tu nuevo test deberÃ­a pasar
#+end_src

*5. Formatear* (opcional pero recomendado):

#+begin_src bash
fourmolu -i src/Exercises/Tema01/Ej14/MiEjercicio.hs
#+end_src

** AÃ±adiendo dependencias externas

*Ejemplo*: Quiero usar ~text~ para trabajar con strings eficientes

*1. Editar ~pensando-en-haskell.cabal~*:

#+begin_src cabal
library
  build-depends:
      base >=4.7 && <5
    , aeson           -- Ya estaba
    , hspec >=2.6 && <3
    , text            -- â† AÃ‘ADIR AQUÃ (automÃ¡ticamente Ãºltima versiÃ³n compatible)
    -- o con versiÃ³n especÃ­fica:
    -- , text >= 2.0 && < 2.1
#+end_src

*2. Ejecutar*:

#+begin_src bash
cabal build  # Cabal descarga 'text' automÃ¡ticamente
#+end_src

*3. Usar en tu cÃ³digo*:

#+begin_src haskell
import qualified Data.Text as T

miTexto :: T.Text
miTexto = T.pack "Hola Haskell!"
#+end_src

*Nota*: No necesitas ~cabal install~ ni nada. Solo aÃ±adir a ~build-depends~ y ~cabal build~.

** Desarrollo rÃ¡pido con ghcid

*ghcid* recompila automÃ¡ticamente cuando guardas archivos. Es MÃGICO.

#+begin_src bash
# En una terminal aparte (dejar corriendo)
ghcid --command='cabal repl'

# Ahora edita cualquier archivo .hs
# ghcid recompila en < 1 segundo y muestra errores
# Â¡Feedback instantÃ¡neo!
#+end_src

En Doom Emacs, ghcid + HLS es imparable:
- *ghcid*: Feedback rÃ¡pido en terminal
- *HLS*: Errores inline, autocompletado, goto definition

-----

* ğŸ”§ Herramientas disponibles

Cuando entras al proyecto con ~direnv~, tienes todo esto:

** Core Toolchain
- *GHC 9.8.4* - Compilador Haskell
- *cabal-install 3.16* - Build tool (lo que usamos)
- *haskell-language-server* - LSP para IDE (Doom Emacs)

** Formatters
- *fourmolu* â­ - Fork configurable de ormolu (recomendado)
- *ormolu* - Formateador opinionado sin config
- *stylish-haskell* - MÃ¡s conservador

#+begin_src bash
# Formatear archivo
fourmolu -i src/MiModulo.hs

# Formatear todo el proyecto
find src test -name "*.hs" -exec fourmolu -i {} \;
#+end_src

** Linting
- *hlint* - Sugerencias de estilo y mejoras

#+begin_src bash
# Ver sugerencias
hlint src/

# Aplicar sugerencias automÃ¡ticamente
hlint src/ --refactor --refactor-options="-i"
#+end_src

** Desarrollo
- *ghcid* - RecompilaciÃ³n ultra-rÃ¡pida (< 1s)
- *hoogle* - BÃºsqueda de documentaciÃ³n
- *gen-hie* - Genera ~hie.yaml~ (ya lo tenemos)

-----

* ğŸ¯ Doom Emacs Shortcuts (si usas Doom)

Abre cualquier archivo ~.hs~ y:

- =SPC c d= - Ir a definiciÃ³n
- =SPC c D= - Encontrar referencias
- =SPC c k= - Mostrar documentaciÃ³n (hover)
- =SPC c r= - Renombrar sÃ­mbolo
- =SPC c f= - Formatear con fourmolu
- =SPC c a= - Code actions (aplicar sugerencias hlint)
- =SPC c x= - Lista de errores
- =SPC m= - Menu especÃ­fico de Haskell

HLS te da:
- âœ… Errores de tipos inline
- âœ… Autocompletado inteligente
- âœ… Hover para ver tipos
- âœ… Refactorings automÃ¡ticos
- âœ… Aplicar sugerencias de hlint

-----

* ğŸš€ Setup desde cero (Nix + Doom Emacs)

Si no tienes nada instalado, aquÃ­ estÃ¡ el setup completo.

** Prerrequisitos

1. *NixOS* o *Nix* con flakes habilitado
2. *Home Manager* configurado
3. *Doom Emacs* instalado
4. *direnv* + *nix-direnv* habilitado en home-manager

** ConfiguraciÃ³n en home-manager

Las herramientas Haskell ya estÃ¡n en =~/dotfiles/home-manager/.config/home-manager/home.nix=:

#+begin_src nix
home.packages = with pkgs; [
  # Core
  haskellPackages.ghc
  haskell-language-server  # Top-level package (wrapper multi-GHC)
  haskellPackages.cabal-install

  # Formatters
  haskellPackages.fourmolu
  haskellPackages.ormolu

  # Linting
  haskellPackages.hlint

  # Development
  haskellPackages.ghcid
  haskellPackages.hoogle
  haskellPackages.implicit-hie

  # System deps
  gmp
  zlib
  gcc
];
#+end_src

Aplicar cambios:

#+begin_src bash
home-manager switch
doom sync  # Si usas Doom Emacs
#+end_src

** ConfiguraciÃ³n de Doom Emacs

En =~/.doom.d/init.el=:

#+begin_src elisp
(doom!
  :tools
  lsp
  direnv
  tree-sitter

  :lang
  (haskell +lsp +test +tree-sitter))
#+end_src

En =~/.doom.d/config.el=:

#+begin_src elisp
;; PATH para herramientas Nix (ya configurado)
(add-to-list 'exec-path (expand-file-name "~/.nix-profile/bin"))

;; IMPORTANTE: Activar envrc globalmente para direnv
(after! envrc
  (envrc-global-mode +1))

;; Habilitar LSP con lsp-deferred (NO lsp directo)
(add-hook 'haskell-mode-hook #'lsp-deferred)
(add-hook 'haskell-literate-mode-hook #'lsp-deferred)

;; LSP con HLS + fourmolu
(after! lsp-haskell
  (setq lsp-haskell-server-path "haskell-language-server-wrapper")
  (setq lsp-haskell-formatting-provider "fourmolu")

  ;; Habilitar plugin eval para -- >>> comments
  (setq lsp-haskell-plugin-eval-on t))
#+end_src

*Importante*: DespuÃ©s de modificar la config:

#+begin_src bash
doom sync    # Sincronizar paquetes
doom reload  # O reiniciar Emacs
#+end_src

-----

* ğŸ“š Estructura del Proyecto

#+begin_example
pensando-en-haskell/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ Exercises/
â”‚   â”‚   â””â”€â”€ Tema01/           # Ejercicios del libro organizados por tema
â”‚   â”‚       â”œâ”€â”€ Ej01/
â”‚   â”‚       â”œâ”€â”€ Ej02/
â”‚   â”‚       â””â”€â”€ ...
â”‚   â”œâ”€â”€ ADNCalculator.hs      # Ejemplos varios
â”‚   â””â”€â”€ Lib.hs
â”œâ”€â”€ test/                      # Tests con HSpec
â”‚   â”œâ”€â”€ Exercises/
â”‚   â””â”€â”€ Spec.hs               # Entry point de tests
â”œâ”€â”€ app/
â”‚   â””â”€â”€ Main.hs               # Ejecutable principal
â”œâ”€â”€ flake.nix                 # âš™ï¸  Entorno de desarrollo Nix
â”œâ”€â”€ hie.yaml                  # ğŸ”§ Config HLS (estructura proyecto)
â”œâ”€â”€ fourmolu.yaml             # ğŸ¨ Estilo de formateo
â”œâ”€â”€ .envrc                    # ğŸ”„ ActivaciÃ³n automÃ¡tica direnv
â””â”€â”€ pensando-en-haskell.cabal # ğŸ“¦ DefiniciÃ³n del proyecto
#+end_example

-----

* ğŸ› Troubleshooting

** ~direnv: error .envrc is blocked~

#+begin_src bash
# Permitir direnv explÃ­citamente
direnv allow
#+end_src

** HLS no arranca en Doom Emacs

#+begin_src bash
# Verificar que HLS estÃ¡ en PATH
which haskell-language-server-wrapper

# DeberÃ­a mostrar: /home/tu-user/.nix-profile/bin/haskell-language-server-wrapper
#+end_src

En Emacs:
#+begin_example
M-x lsp-workspace-show-log  # Ver logs de LSP
M-x lsp-describe-session    # Ver estado de la sesiÃ³n
#+end_example

** ~GHC ABIs don't match!~ (IMPORTANTE)

Si ves este error:
#+begin_example
GHC ABIs don't match!
Expected: ghc-9.8.4:XXXXXXX
Got:      ghc-9.8.4:YYYYYYY
#+end_example

*Causa*: HLS fue compilado con una versiÃ³n de GHC diferente (aunque sea el mismo nÃºmero de versiÃ³n).

*SoluciÃ³n*:

1. *NUNCA* instalar HLS globalmente en home-manager si usas diferentes versiones de nixpkgs entre el sistema y los proyectos.

2. El flake *DEBE* usar ~nixos-25.05~ (stable) NO ~nixos-unstable~:

#+begin_src nix
inputs = {
  nixpkgs.url = "github:NixOS/nixpkgs/nixos-25.05";  # â† Importante
  flake-utils.url = "github:numtide/flake-utils";
};
#+end_src

3. HLS debe venir del ~pkgs~ top-level del flake:

#+begin_src nix
] ++ (with pkgs; [
  haskell-language-server  # â† Del mismo nixpkgs que GHC
#+end_src

*NO* usar ~hsPkgs.haskell-language-server~ (compilarÃ­a desde source y fallarÃ­a).

4. Asegurar que direnv/envrc estÃ¡ cargando el environment:

#+begin_src bash
# En el directorio del proyecto
direnv reload

# Verificar que cargÃ³
echo $IN_NIX_SHELL  # DeberÃ­a mostrar: impure
#+end_src

5. Reiniciar el daemon de Emacs completamente:

#+begin_src bash
emacsclient -e '(kill-emacs)'
# Esperar un momento
emacsclient -nw ~/src/pensando-en-haskell
#+end_src

** ~cabal: Could not resolve dependencies~

Significa que las versiones en ~build-depends~ no son compatibles.

*SoluciÃ³n 1*: Dejar que Cabal elija versiones automÃ¡ticamente:

#+begin_src cabal
build-depends: base >=4.7 && <5
             , text  -- Sin especificar versiÃ³n
#+end_src

*SoluciÃ³n 2*: Ver quÃ© versiÃ³n funciona:

#+begin_src bash
cabal build --allow-newer  # Permite versiones mÃ¡s nuevas
#+end_src

** Build muy lento la primera vez

*Normal*. La primera build descarga y compila dependencias (aeson, hspec, etc.). Las siguientes builds son rÃ¡pidas porque Cabal cachea todo.

#+begin_src bash
# Primera vez
cabal build  # ~2-5 minutos

# Siguientes veces
cabal build  # ~5-20 segundos (solo recompila cambios)
#+end_src

** ~git tree is dirty~ warning de direnv

Es solo un warning, no afecta. Significa que hay cambios sin commitear.

-----

* ğŸ“– Recursos de Aprendizaje

** Libros (ordenados por dificultad)

1. [[http://www.cs.us.es/~jalonso/publicaciones/Piensa_en_Haskell.pdf][Piensa en Haskell]] â­ - El libro de este repo (EN ESPAÃ‘OL)
2. [[http://learnyouahaskell.com/][Learn You a Haskell]] - Divertido, ilustrado, para empezar
3. [[https://haskellbook.com/][Haskell Programming from First Principles]] - El mÃ¡s completo (de pago)

** Cursos y Tutoriales

- [[https://github.com/haskell-beginners-2022/course-plan][Haskell Beginners 2022 Course]] - Curso completo gratis
- [[https://typeclasses.com/beginner-crash-course/types-and-functions-1][Type Classes - Beginner Crash Course]]
- [[https://www.fpcomplete.com/haskell/tutorial/][FP Complete - Haskell Tutorial]]

** Referencias RÃ¡pidas

- [[https://hoogle.haskell.org/][Hoogle]] - Busca funciones por nombre o tipo
- [[https://hackage.haskell.org/][Hackage]] - Repositorio de paquetes Haskell
- [[https://cheatsheet.codeslower.com/CheatSheet.pdf][Haskell Cheatsheet]]

-----

* ğŸ”§ Archivos de ConfiguraciÃ³n Explicados

** ~flake.nix~ - Entorno de desarrollo

Define quÃ© herramientas estÃ¡n disponibles en el proyecto. Usa *nixpkgs haskellPackages* (enfoque estÃ¡ndar Nix).

#+begin_src nix
{
  description = "Entorno Haskell con GHC 9.8";

  # GHC, cabal, fourmolu, hlint, ghcid, etc.
  # Se activan automÃ¡ticamente con direnv
}
#+end_src

*No necesitas tocarlo* a menos que quieras cambiar versiÃ³n de GHC o aÃ±adir herramientas del sistema.

** ~hie.yaml~ - ConfiguraciÃ³n HLS

Le dice a HLS cÃ³mo estÃ¡ estructurado tu proyecto (lib, exe, test).

#+begin_src yaml
cradle:
  cabal:
    - path: "./src"
      component: "lib:pensando-en-haskell"
    - path: "./test"
      component: "pensando-en-haskell:test:pensando-en-haskell-test"
#+end_src

*Regenerar si aÃ±ades componentes nuevos*:

#+begin_src bash
gen-hie > hie.yaml
#+end_src

** ~fourmolu.yaml~ - Estilo de cÃ³digo

ConfiguraciÃ³n del formateador (indentaciÃ³n, imports, etc.).

#+begin_src yaml
indentation: 2
comma-style: leading
diff-friendly-import-export: true
#+end_src

*Personalizar* segÃºn preferencias del equipo.

** ~pensando-en-haskell.cabal~ - DefiniciÃ³n del proyecto

El archivo mÃ¡s importante. Define:
- QuÃ© mÃ³dulos expone tu librerÃ­a (~exposed-modules~)
- Dependencias externas (~build-depends~)
- Ejecutables y tests

*Este sÃ­ lo editarÃ¡s* constantemente al aÃ±adir mÃ³dulos y dependencias.

-----

* ğŸ¤“ ApÃ©ndice: Por quÃ© este setup tÃ©cnico

** TL;DR: nixpkgs es suficiente para aprender

Este proyecto usa *nixpkgs haskellPackages*, el enfoque estÃ¡ndar de Nix para Haskell.

*Â¿Por quÃ© no Stack?*
- Stack y Nix juntos son incÃ³modos (ambos gestionan dependencias)
- Cabal es mÃ¡s simple y se integra mejor con Nix

*Â¿Por quÃ© no haskell.nix?*
- MÃ¡s complejo (IFD, materializaciÃ³n, cache propio)
- Overkill para aprender Haskell
- haskell.nix es para cross-compilation y proyectos industriales

*Â¿Por quÃ© no haskell-flake?*
- Es buena opciÃ³n, pero aÃ±ade abstracciÃ³n extra
- Para este proyecto educativo, nixpkgs raw es suficiente y mÃ¡s directo

** ComparaciÃ³n rÃ¡pida de enfoques Nix+Haskell

| Enfoque              | Complejidad | Mejor para                   | Flexibilidad |
|----------------------+-------------+------------------------------+--------------|
| *nixpkgs* â­         | Baja        | Proyectos estÃ¡ndar, aprender | Media        |
| *haskell-flake*      | Media       | Equipos, monorepos           | Media        |
| *haskell.nix*        | Alta        | Cross-compilation, industria | MÃ¡xima       |

*Para aprender Haskell*: nixpkgs es perfecto. Simple, cacheado, reproducible.

*Para producciÃ³n/empresa*: Considera haskell-flake o haskell.nix segÃºn necesidades.

** Trade-off: Consistencia vs Libertad

*nixpkgs*: Un conjunto consistente de paquetes (como una distribuciÃ³n Linux)
- âœ… Todo funciona junto sin conflictos
- âœ… Cache binario excelente (builds rÃ¡pidos)
- âŒ Solo versiones del snapshot (actualmente GHC 9.8)
- âŒ Ignora restricciones de versiÃ³n de Cabal

*haskell.nix*: Libertad total (como compilar todo desde source)
- âœ… Cualquier versiÃ³n de cualquier paquete
- âœ… Respeta restricciones exactas de Cabal
- âŒ MÃ¡s complejo (IFD, materializaciÃ³n)
- âŒ Cache menos completo

*Este proyecto*: nixpkgs es suficiente porque:
1. No necesitamos versiones especÃ­ficas raras
2. Aprendiendo Haskell, no manteniendo software crÃ­tico
3. Queremos setup simple que funcione

Si algÃºn dÃ­a necesitas haskell.nix, la migraciÃ³n es posible (pero este README ya serÃ­a otro).

-----

* ğŸ“ FilosofÃ­a del Repo

*Objetivo*: Bajar la barrera de entrada a Haskell.

La configuraciÃ³n de entorno en Haskell puede ser frustrante. Este repo ofrece:
- âœ… Setup que funciona out-of-the-box
- âœ… Ejemplos reales de ejercicios
- âœ… Tests como documentaciÃ³n
- âœ… Herramientas modernas (HLS, ghcid, formatters)

*No es*: Un template perfecto para producciÃ³n.

*Es*: Un entorno cÃ³modo para aprender sin pelear con tooling.

-----

* ğŸ¤ Contribuir

Â¿Encontraste un error? Â¿MejorarÃ­as algo? *Â¡PR bienvenidos!*

Ãreas donde ayuda serÃ­a genial:
- MÃ¡s ejercicios resueltos con tests
- Explicaciones en espaÃ±ol de conceptos difÃ­ciles
- Mejoras al README (siempre se puede mejorar)
- Alternativas de setup mÃ¡s simples

-----

* ğŸ“œ Licencia

MIT - Haz lo que quieras con este cÃ³digo.

-----

*Â¡Feliz Haskelling! ğŸš€*

Si este repo te sirviÃ³, dale una â­ para que otros noobskells lo encuentren.
