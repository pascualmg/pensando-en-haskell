#+TITLE: Pensando en Haskell
#+AUTHOR: pascualmg
#+DATE: 2025
#+OPTIONS: toc:2 num:nil
#+PROPERTY: header-args:haskell :results value :exports both

#+begin_quote
âš ï¸ *IMPORTANTE*: Este proyecto usa ~nixos-25.05~ (stable) NO ~nixos-unstable~.

RazÃ³n: Compatibilidad entre HLS y GHC 9.8.4. Ver secciÃ³n [[*~GHC ABIs don't match!~ (IMPORTANTE)][Troubleshooting â†’ GHC ABIs don't match]].
#+end_quote

* README Interactivo ğŸ®

Este README estÃ¡ en formato Org-mode, lo que significa que los snippets de cÃ³digo Haskell son *ejecutables* directamente en Emacs:

1. Coloca el cursor en cualquier bloque ~#+begin_src haskell~
2. Presiona ~C-c C-c~
3. Â¡El cÃ³digo se ejecuta y ves el resultado!

*Nota*: Para que funcione, necesitas tener configurado ~ob-haskell~ en Doom Emacs (ya lo tienes si seguiste el setup).

-----

* Repo para practicar con los ejercicios del libro

*Libros principales*:
- [[http://www.cs.us.es/~jalonso/publicaciones/Piensa_en_Haskell.pdf][Piensa en Haskell]] (JosÃ© A. Alonso JimÃ©nez & Ma JosÃ© Hidalgo Doblado)
- [[http://learnyouahaskell.com/][Â¡Aprende Haskell por el Bien de Todos!]] / Learn You a Haskell for Great Good! (Miran LipovaÄa)

* MotivaciÃ³n y para quiÃ©n es Ãºtil esto

Este repo Ãºnicamente te va a servir de algo si eres un *noobskell* como yo, no tienes ni idea de cÃ³mo empezar, ni estÃ¡s en la uni con esos profesores autores del libro, pero andas con ganas de probar este lenguaje de programaciÃ³n puramente funcional y escapar de esa cÃ¡rcel de la PğŸ’©ğŸ’©

Este repo se crea para autodidactas, como el que lo escribe, con la intenciÃ³n de tener una pequeÃ±a referencia para los primeros pasos que hay que dar para aprender a programar en Haskell. A veces, precisamente lo mÃ¡s difÃ­cil es poder configurar un entorno de depuraciÃ³n amigable y familiarizarse con las herramientas necesarias para conseguir ejecutar algo.

La idea es dejar en este README los enlaces mÃ¡s interesantes que encuentre y mis propias anotaciones para usarlas como guÃ­a, principalmente para mÃ­, ya que creo que difÃ­cilmente estÃ© alguien mÃ¡s interesado. Si es asÃ­, hÃ¡zmelo saber con una â­ o un PR.

-----

* ğŸƒ Quick Start (5 minutos)

*Si ya tienes NixOS/Nix con flakes:*

#+begin_src bash
# 1. Clonar
git clone https://github.com/pascualmg/pensando-en-haskell
cd pensando-en-haskell

# 2. Activar entorno (solo primera vez)
direnv allow

# VerÃ¡s un mensaje bonito con las herramientas disponibles
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“ Entorno Haskell - Pensando en Haskell
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# GHC: 9.8.4
# Cabal: 3.16.0.0
# ...

# 3. Primera build (tarda un poco, descarga dependencias)
cabal update  # Solo primera vez
cabal build

# 4. Ejecutar
cabal run pensando-en-haskell-exe

# 5. Tests
cabal test

# âœ… Â¡YA ESTÃ! Ahora puedes empezar a programar
#+end_src

*Si no tienes Nix*, mira la secciÃ³n [[*ğŸš€ Setup desde cero (Nix + Doom Emacs)][Setup desde cero]] mÃ¡s abajo.

-----

* ğŸ® Ejemplos Interactivos (Â¡PruÃ©balos con C-c C-c!)

Estos ejemplos son ejecutables directamente en este README si lo abres con Doom Emacs:

** Ejemplo 1: Operaciones bÃ¡sicas

#+begin_src haskell
-- Suma simple
2 + 3
#+end_src

** Ejemplo 2: Funciones

#+begin_src haskell
-- Definir y usar una funciÃ³n
let suma3 x y z = x + y + z
in suma3 10 20 30
#+end_src

** Ejemplo 3: Listas y funciones de orden superior

#+begin_src haskell
-- Filtrar nÃºmeros pares y sumarlos
sum (filter even [1..10])
#+end_src

** Ejemplo 4: List comprehensions

#+begin_src haskell
-- Pares ordenados donde la suma es 10
[(x, y) | x <- [1..10], y <- [1..10], x + y == 10, x <= y]
#+end_src

** Ejemplo 5: RecursiÃ³n (factorial)

#+begin_src haskell
let factorial 0 = 1
    factorial n = n * factorial (n - 1)
in factorial 5
#+end_src

** Ejemplo 6: Tipos y polimorfismo

#+begin_src haskell
-- Longitud de diferentes tipos de listas
length [1, 2, 3, 4, 5]
#+end_src

#+begin_src haskell
length ["hola", "mundo", "haskell"]
#+end_src

** Ejemplo 7: Pattern matching

#+begin_src haskell
let describeLista [] = "Lista vacÃ­a"
    describeLista [x] = "Lista con un elemento: " ++ show x
    describeLista (x:y:_) = "Lista que empieza con " ++ show x ++ " y " ++ show y
in describeLista [1, 2, 3, 4]
#+end_src

*Nota*: Coloca el cursor en cualquier bloque y presiona ~C-c C-c~ para ejecutarlo. Â¡El resultado aparecerÃ¡ justo debajo!

-----

* ğŸ’» Desarrollo Diario (Lo que usarÃ¡s siempre)

** Comandos esenciales de Cabal

#+begin_src bash
# â•â•â• COMPILAR â•â•â•
cabal build                    # Compila todo el proyecto
cabal build pensando-en-haskell-exe  # Solo el ejecutable

# â•â•â• EJECUTAR â•â•â•
cabal run pensando-en-haskell-exe    # Compila (si hace falta) y ejecuta

# â•â•â• TESTS â•â•â•
cabal test                     # Ejecuta todos los tests (HSpec)
cabal test --test-show-details=direct  # Muestra output detallado

# â•â•â• REPL INTERACTIVO â•â•â•
cabal repl                     # GHCi con tu proyecto cargado
# Dentro del REPL:
# > :l src/MiModulo.hs          -- Cargar mÃ³dulo
# > :r                          -- Recargar cambios
# > :t miFuncion                -- Ver tipo
# > miFuncion argumentos         -- Ejecutar
# > :q                          -- Salir

# â•â•â• LIMPIAR â•â•â•
cabal clean                    # Borra builds (si algo va raro)
#+end_src

** Workflow real: AÃ±adiendo un ejercicio nuevo

*Ejemplo*: Vamos a aÃ±adir Ejercicio 14 del Tema 1

*1. Crear el mÃ³dulo* (~src/Exercises/Tema01/Ej14/MiEjercicio.hs~):

#+begin_src haskell
module Exercises.Tema01.Ej14.MiEjercicio (suma3) where

-- | Suma tres nÃºmeros
suma3 :: Int -> Int -> Int -> Int
suma3 x y z = x + y + z

-- >>> suma3 1 2 3
-- 6
#+end_src

*2. Crear el test* (~test/Exercises/Tema01/Ej14/MiEjercicioSpec.hs~):

#+begin_src haskell
module Exercises.Tema01.Ej14.MiEjercicioSpec (spec) where

import Test.Hspec
import Exercises.Tema01.Ej14.MiEjercicio

spec :: Spec
spec = describe "suma3" $ do
  it "suma tres nÃºmeros correctamente" $
    suma3 1 2 3 `shouldBe` 6
#+end_src

*3. Registrar en ~.cabal~* (~pensando-en-haskell.cabal~):

#+begin_src cabal
library
  exposed-modules:
      -- ... otros mÃ³dulos
      Exercises.Tema01.Ej14.MiEjercicio  -- â† AÃ±adir aquÃ­
#+end_src

Y en la secciÃ³n de tests:

#+begin_src cabal
test-suite pensando-en-haskell-test
  other-modules:
      -- ... otros tests
      Exercises.Tema01.Ej14.MiEjercicioSpec  -- â† AÃ±adir aquÃ­
#+end_src

*4. Compilar y probar*:

#+begin_src bash
cabal build  # DeberÃ­a compilar sin errores
cabal test   # Tu nuevo test deberÃ­a pasar
#+end_src

*5. Formatear* (opcional pero recomendado):

#+begin_src bash
fourmolu -i src/Exercises/Tema01/Ej14/MiEjercicio.hs
#+end_src

** ğŸ“¦ HOWTO: AÃ±adir una dependencia externa

*IMPORTANTE*: Este proyecto usa ~.cabal~ directamente (NO ~package.yaml~). Edita el archivo ~pensando-en-haskell.cabal~ manualmente.

*** Paso 1: Entender dÃ³nde aÃ±adir la dependencia

El ~.cabal~ tiene 3 secciones con ~build-depends~:

#+begin_example
library               â†’ CÃ³digo en src/
executable            â†’ CÃ³digo en app/ (Main.hs)
test-suite            â†’ Tests en test/
#+end_example

*Regla*: AÃ±ade la dependencia donde la vayas a usar.

*** Paso 2: Editar pensando-en-haskell.cabal

*Ejemplo real*: AÃ±adir ~http-conduit~ para hacer peticiones HTTP desde ~app/Main.hs~

Busca la secciÃ³n ~executable pensando-en-haskell-exe~ y aÃ±ade a ~build-depends~:

#+begin_src cabal
executable pensando-en-haskell-exe
  main-is: Main.hs
  hs-source-dirs: app
  ghc-options: -threaded -rtsopts -with-rtsopts=-N
  build-depends:
      base >=4.7 && <5
    , pensando-en-haskell
    , http-conduit        -- â† AÃ‘ADIR AQUÃ
#+end_src

*Tips*:
- Sin versiÃ³n â†’ Cabal elige la Ãºltima compatible automÃ¡ticamente
- Con versiÃ³n â†’ ~, http-conduit >= 2.3 && < 2.4~
- Usa comas al inicio (estilo ~, paquete~) para legibilidad

*** Paso 3: Compilar con direnv

*IMPORTANTE*: Ejecuta siempre dentro del entorno direnv:

#+begin_src bash
direnv exec . cabal build
# O si direnv ya estÃ¡ cargado en tu shell:
cabal build
#+end_src

Cabal descarga y compila la dependencia automÃ¡ticamente.

*** Paso 4: Recargar HLS en Emacs

HLS no detecta cambios en ~.cabal~ automÃ¡ticamente. ReinÃ­cialo:

#+begin_src emacs-lisp
M-x lsp-workspace-restart
# O el atajo:
SPC c R
#+end_src

Ahora HLS conoce la nueva dependencia â†’ autocompletado funciona.

*** Paso 5: Usar en tu cÃ³digo

#+begin_src haskell
-- En app/Main.hs
import Network.HTTP.Simple

main :: IO ()
main = do
  response <- httpBS "https://httpbin.org/get"
  print $ getResponseStatusCode response
#+end_src

*** Troubleshooting

*Error: ~Could not load module 'Network.HTTP.Simple'~*
â†’ La dependencia no estÃ¡ en el ~build-depends~ correcto. Verifica que estÃ© en la secciÃ³n donde usas el import (executable, library o test).

*Error: ~Missing C library: z~*
â†’ Falta una librerÃ­a del sistema. AÃ±Ã¡dela a ~flake.nix~ en ~System dependencies~ y ejecuta ~direnv reload~.

*** Resumen rÃ¡pido

#+begin_src bash
# 1. Editar pensando-en-haskell.cabal (aÃ±adir a build-depends)
# 2. Compilar
direnv exec . cabal build
# 3. Recargar HLS en Emacs
M-x lsp-workspace-restart
#+end_src

** Desarrollo rÃ¡pido con ghcid

*ghcid* recompila automÃ¡ticamente cuando guardas archivos. Es MÃGICO.

#+begin_src bash
# En una terminal aparte (dejar corriendo)
ghcid --command='cabal repl'

# Ahora edita cualquier archivo .hs
# ghcid recompila en < 1 segundo y muestra errores
# Â¡Feedback instantÃ¡neo!
#+end_src

En Doom Emacs, ghcid + HLS es imparable:
- *ghcid*: Feedback rÃ¡pido en terminal
- *HLS*: Errores inline, autocompletado, goto definition

-----

* ğŸ”§ Herramientas disponibles

Cuando entras al proyecto con ~direnv~, tienes todo esto automÃ¡ticamente en el PATH:

** Core Toolchain
- *GHC 9.8.4* - Compilador Haskell
- *cabal-install 3.16* - Build tool (lo que usamos)
- *haskell-language-server* - LSP para IDE (Doom Emacs)

** ğŸ¨ Formatters (hacer cÃ³digo bonito)

*** fourmolu â­ (recomendado)

Fork configurable de ormolu. Usa =fourmolu.yaml= del proyecto.

#+begin_src bash
# Formatear UN archivo
fourmolu -i src/Exercises/Tema01/Ej01/MediaDeTresNumeros.hs

# Formatear TODO el proyecto
fourmolu -i $(find src test app -name "*.hs")

# Ver quÃ© cambiarÃ­a SIN modificar (dry-run)
fourmolu src/MiModulo.hs

# Formatear solo archivos modificados (git)
git diff --name-only | grep ".hs$" | xargs fourmolu -i
#+end_src

*En Doom Emacs*: ~SPC c f~ formatea automÃ¡ticamente con fourmolu (ya configurado).

*** ormolu (alternativa)

MÃ¡s opinionado, sin configuraciÃ³n posible.

#+begin_src bash
ormolu -i src/MiModulo.hs
#+end_src

*** Personalizar fourmolu

Edita =fourmolu.yaml= en la raÃ­z del proyecto:

#+begin_src yaml
indentation: 2              # Espacios de indentaciÃ³n
comma-style: leading        # Comas al principio en listas
diff-friendly-import-export: true
respectful: true            # No reformatear TODO agresivamente
#+end_src

** ğŸ” Linting (sugerencias de mejora)

*** hlint

Sugiere mejoras de estilo, funciones mÃ¡s idiomÃ¡ticas, y optimizaciones.

#+begin_src bash
# Ver todas las sugerencias del proyecto
hlint src/ test/ app/

# Ver sugerencias de UN archivo
hlint src/Exercises/Tema01/Ej02/SumaEurosColeccionMonedas.hs

# Aplicar sugerencias automÃ¡ticamente (CUIDADO: revisa despuÃ©s)
hlint src/ --refactor --refactor-options="-i"

# Generar reporte HTML
hlint src/ --report=hlint-report.html

# Ignorar ciertas sugerencias
hlint src/ --ignore="Use camelCase"
#+end_src

*Ejemplo de output*:

#+begin_example
src/Lib.hs:23:1: Suggestion: Use newtype instead of data
Found:
  data Wrapper = Wrapper Int
Why not:
  newtype Wrapper = Wrapper Int
#+end_example

*En Doom Emacs*: ~SPC c a~ te muestra code actions de hlint integradas con LSP.

** ğŸš€ Desarrollo RÃ¡pido

*** ghcid (recompilaciÃ³n automÃ¡tica instantÃ¡nea)

Recompila tu cÃ³digo cada vez que guardas un archivo. *SÃšPER RÃPIDO*.

#+begin_src bash
# Monitorear todo el proyecto
ghcid --command='cabal repl'

# Monitorear solo tests
ghcid --command='cabal repl pensando-en-haskell-test'

# Monitorear Y ejecutar un comando al compilar OK
ghcid --command='cabal repl' --test='main'

# Con colores bonitos
ghcid --command='cabal repl' --color=always
#+end_src

*Tip*: Deja ghcid corriendo en una terminal mientras programas. VerÃ¡s errores al instante.

#+begin_example
All good (8 modules, at 14:32:05)

# Guardas archivo con error...

src/Lib.hs:23:5: error:
    â€¢ Couldn't match expected type 'Int' with actual type 'String'
    â€¢ In the expression: "hola"

# Lo arreglas y guardas...

All good (8 modules, at 14:32:12)
#+end_example

*** hoogle (buscar funciones por nombre o tipo)

Busca funciones, tipos, mÃ³dulos en toda la documentaciÃ³n de Haskell.

#+begin_src bash
# Buscar por nombre
hoogle "map"
hoogle "sort"

# Buscar por TIPO (lo mÃ¡s Ãºtil)
hoogle "(a -> b) -> [a] -> [b]"
# â†’ Devuelve: map :: (a -> b) -> [a] -> [b]

hoogle "[a] -> Int"
# â†’ Devuelve: length, sum, product...

hoogle "Ord a => [a] -> [a]"
# â†’ Devuelve: sort, nub, group...

# Buscar en un paquete especÃ­fico
hoogle "decode" +aeson

# Ver documentaciÃ³n completa
hoogle "map" --info
#+end_src

*Online*: TambiÃ©n disponible en https://hoogle.haskell.org/

*En Doom Emacs*: Puedes configurar un keybinding para hoogle (ver secciÃ³n Doom Emacs).

*** gen-hie (regenerar configuraciÃ³n HLS)

Si aÃ±ades nuevos componentes al =.cabal= (por ejemplo, un segundo ejecutable), regenera =hie.yaml=:

#+begin_src bash
# Regenerar hie.yaml automÃ¡ticamente
gen-hie > hie.yaml

# Ver quÃ© generarÃ­a SIN escribir archivo
gen-hie
#+end_src

Luego reinicia LSP en Emacs: ~M-x lsp-workspace-restart~

** ğŸ“¦ Herramientas del sistema (incluidas en flake)

*** zlib, gmp, pkg-config

LibrerÃ­as C necesarias para compilar ciertos paquetes de Haskell.

Ya estÃ¡n incluidas en =flake.nix=, no necesitas hacer nada.

** ğŸ¯ Workflow completo con todas las herramientas

*** Antes de commitear:

#+begin_src bash
# 1. Formatear todo
fourmolu -i $(git diff --name-only --cached | grep ".hs$")

# 2. Ver sugerencias de hlint
hlint src/ test/ app/

# 3. Compilar
cabal build

# 4. Tests
cabal test

# 5. Todo OK? Commit!
git commit
#+end_src

*** Durante el desarrollo:

#+begin_example
Terminal 1: ghcid --command='cabal repl'  # Auto-recompilaciÃ³n
Terminal 2: cabal test --test-show-details=streaming  # Tests
Emacs: Escribiendo cÃ³digo con LSP activo
#+end_example

** ğŸ› ï¸ AÃ±adir mÃ¡s herramientas al flake

Si quieres aÃ±adir una herramienta nueva (ejemplo: =stan= para anÃ¡lisis estÃ¡tico):

1. Edita =flake.nix=:

#+begin_src nix
packages = with hsPkgs; [
  ghc
  cabal-install
  # ... otras herramientas
  stan  # â† AÃ±adir aquÃ­
] ++ (with pkgs; [
  # ...
]);
#+end_src

2. Recarga direnv:

#+begin_src bash
direnv reload
#+end_src

3. Verifica:

#+begin_src bash
which stan  # DeberÃ­a mostrar el path en /nix/store/...
#+end_src

-----

* ğŸ¯ Doom Emacs: GuÃ­a Completa de Comandos

** Lo esencial (memoriza estos 5)

| Keybinding | DescripciÃ³n                     | Uso                           |
|------------+---------------------------------+-------------------------------|
| ~K~        | Ver tipo y documentaciÃ³n        | â­ EL MÃS ÃšTIL - Ãºsalo siempre |
| ~gd~       | Ir a definiciÃ³n                 | Navegar cÃ³digo                |
| ~SPC c a~  | Code actions (imports, fixes)   | Arreglar errores automÃ¡tico   |
| ~SPC c f~  | Formatear con fourmolu          | Antes de commitear            |
| ~] d~      | Siguiente error                 | Revisar errores uno por uno   |

** NavegaciÃ³n de CÃ³digo

| Keybinding | Comando                   | DescripciÃ³n                         |
|------------+---------------------------+-------------------------------------|
| ~K~        | ~lsp-describe-thing-at-point~ | Ver tipo y documentaciÃ³n            |
| ~gd~       | ~+lookup/definition~      | Ir a definiciÃ³n                     |
| ~gD~       | ~+lookup/declaration~     | Ir a declaraciÃ³n                    |
| ~gr~       | ~+lookup/references~      | Ver todas las referencias           |
| ~C-o~      | ~evil-jump-backward~      | Volver atrÃ¡s en historial de saltos |
| ~C-i~      | ~evil-jump-forward~       | Avanzar en historial                |

** Code Actions y Refactoring (~SPC c~)

| Keybinding | Comando              | DescripciÃ³n                        |
|------------+----------------------+------------------------------------|
| ~SPC c a~  | ~lsp-execute-code-action~ | Auto-imports, fixes automÃ¡ticos    |
| ~SPC c r~  | ~lsp-rename~         | Renombrar sÃ­mbolo en todo proyecto |
| ~SPC c f~  | ~+format/buffer~     | Formatear buffer con fourmolu      |
| ~SPC c k~  | ~+lookup/documentation~ | Ver documentaciÃ³n completa         |
| ~SPC c d~  | ~+lookup/definition~ | Ir a definiciÃ³n (igual que gd)     |
| ~SPC c D~  | ~+lookup/references~ | Ver referencias (igual que gr)     |

** Errores y DiagnÃ³sticos

| Keybinding | Comando              | DescripciÃ³n                   |
|------------+----------------------+-------------------------------|
| ~] d~      | ~flycheck-next-error~    | Siguiente error/warning       |
| ~[ d~      | ~flycheck-previous-error~ | Error/warning anterior        |
| ~SPC c x~  | ~flycheck-list-errors~   | Lista errores del buffer      |
| ~SPC c X~  | ~lsp-treemacs-errors-list~ | Lista errores del proyecto    |

** BÃºsqueda (~SPC s~)

| Keybinding | Comando                 | DescripciÃ³n                  |
|------------+-------------------------+------------------------------|
| ~SPC s s~  | ~+default/search-buffer~  | Buscar en buffer actual      |
| ~SPC s p~  | ~+default/search-project~ | Buscar en todo el proyecto   |
| ~SPC s i~  | ~lsp-ui-imenu~          | Buscar sÃ­mbolos (funciones)  |

** Proyecto (~SPC p~)

| Keybinding | Comando               | DescripciÃ³n          |
|------------+-----------------------+----------------------|
| ~SPC p p~  | ~projectile-switch-project~ | Cambiar de proyecto  |
| ~SPC p f~  | ~projectile-find-file~      | Buscar archivo       |
| ~SPC p c~  | ~projectile-compile-project~ | Compilar proyecto    |
| ~SPC p t~  | ~projectile-test-project~   | Ejecutar tests       |

** REPL (GHCi)

| Comando                         | DescripciÃ³n                   |
|---------------------------------+-------------------------------|
| ~M-x run-haskell~               | Abrir REPL de Haskell (GHCi)  |
| ~M-x haskell-process-load-file~ | Cargar archivo actual en REPL |

Dentro del REPL:
#+begin_src haskell
:l Main              -- Cargar mÃ³dulo Main
:r                   -- Recargar mÃ³dulo actual
:t expresion         -- Ver tipo de expresiÃ³n
:i nombre            -- Ver info sobre funciÃ³n/tipo
:q                   -- Salir del REPL
#+end_src

** Workflows PrÃ¡cticos

*** Workflow 1: Explorando cÃ³digo existente

#+begin_example
1. SPC p f â†’ Abro archivo
2. Veo una funciÃ³n interesante
3. K sobre ella â†’ veo su tipo
4. gd â†’ salto a su definiciÃ³n
5. gr â†’ veo dÃ³nde se usa
6. C-o â†’ vuelvo donde estaba
#+end_example

*** Workflow 2: Escribiendo cÃ³digo nuevo

#+begin_example
1. Empiezo a escribir una funciÃ³n
2. Autocompletado me sugiere
3. LSP muestra errores en rojo
4. SPC c a â†’ imports automÃ¡ticos
5. SPC c f â†’ formateo
6. :w â†’ guardo
#+end_example

*** Workflow 3: Debugging un error

#+begin_example
1. Veo error en rojo
2. Hover sobre Ã©l â†’ leo mensaje
3. ] d â†’ siguiente error
4. SPC c a â†’ fix automÃ¡tico
5. Si no, corrijo manual
6. SPC c f â†’ formateo
7. Verifico que desaparece
#+end_example

*** Workflow 4: Refactoring

#+begin_example
1. Quiero renombrar funciÃ³n
2. Cursor sobre el nombre
3. SPC c r â†’ rename
4. Escribo nuevo nombre
5. Enter â†’ cambia en TODO el proyecto
6. SPC p c â†’ compilo para verificar
#+end_example

** Lo que HLS te da automÃ¡ticamente

- âœ… Errores de tipos inline
- âœ… Autocompletado inteligente
- âœ… Hover para ver tipos
- âœ… Refactorings automÃ¡ticos
- âœ… Aplicar sugerencias de hlint
- âœ… Auto-imports
- âœ… Formateo con fourmolu

** Debugging LSP

| Comando                    | DescripciÃ³n                    |
|----------------------------+--------------------------------|
| ~M-x lsp-describe-session~ | Ver sesiÃ³n LSP activa          |
| ~M-x lsp-workspace-restart~ | Reiniciar LSP                  |
| ~M-x lsp-doctor~           | Diagnosticar problemas con LSP |
| ~SPC h l~                  | Ver buffer ~*Messages*~        |

** ConfiguraciÃ³n actual (minimalista)

Tu config en =~/.config/doom/config.el= solo tiene esto:

#+begin_src elisp
;; ConfiguraciÃ³n mÃ­nima: Doom maneja todo con +lsp +tree-sitter
(after! lsp-haskell
  (setq lsp-haskell-formatting-provider "fourmolu"))
#+end_src

Todo lo demÃ¡s funciona automÃ¡ticamente con:
- ~(haskell +lsp +tree-sitter +test)~ en =init.el=
- direnv + flake.nix del proyecto

-----

* ğŸš€ Setup desde cero (Nix + Doom Emacs)

Si no tienes nada instalado, aquÃ­ estÃ¡ el setup completo.

** Prerrequisitos

1. *NixOS* o *Nix* con flakes habilitado
2. *Home Manager* configurado
3. *Doom Emacs* instalado
4. *direnv* + *nix-direnv* habilitado en home-manager

** ConfiguraciÃ³n en home-manager

Las herramientas Haskell ya estÃ¡n en =~/dotfiles/home-manager/.config/home-manager/home.nix=:

#+begin_src nix
home.packages = with pkgs; [
  # Core
  haskellPackages.ghc
  haskell-language-server  # Top-level package (wrapper multi-GHC)
  haskellPackages.cabal-install

  # Formatters
  haskellPackages.fourmolu
  haskellPackages.ormolu

  # Linting
  haskellPackages.hlint

  # Development
  haskellPackages.ghcid
  haskellPackages.hoogle
  haskellPackages.implicit-hie

  # System deps
  gmp
  zlib
  gcc
];
#+end_src

Aplicar cambios:

#+begin_src bash
home-manager switch
doom sync  # Si usas Doom Emacs
#+end_src

** ConfiguraciÃ³n de Doom Emacs

En =~/.doom.d/init.el=:

#+begin_src elisp
(doom!
  :tools
  lsp
  direnv
  tree-sitter

  :lang
  (haskell +lsp +test +tree-sitter))
#+end_src

En =~/.doom.d/config.el=:

#+begin_src elisp
;; PATH para herramientas Nix (ya configurado)
(add-to-list 'exec-path (expand-file-name "~/.nix-profile/bin"))

;; IMPORTANTE: Activar envrc globalmente para direnv
(after! envrc
  (envrc-global-mode +1))

;; Habilitar LSP con lsp-deferred (NO lsp directo)
(add-hook 'haskell-mode-hook #'lsp-deferred)
(add-hook 'haskell-literate-mode-hook #'lsp-deferred)

;; LSP con HLS + fourmolu
(after! lsp-haskell
  (setq lsp-haskell-server-path "haskell-language-server-wrapper")
  (setq lsp-haskell-formatting-provider "fourmolu")

  ;; Habilitar plugin eval para -- >>> comments
  (setq lsp-haskell-plugin-eval-on t))
#+end_src

*Importante*: DespuÃ©s de modificar la config:

#+begin_src bash
doom sync    # Sincronizar paquetes
doom reload  # O reiniciar Emacs
#+end_src

-----

* ğŸ“š Estructura del Proyecto

#+begin_example
pensando-en-haskell/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ Exercises/
â”‚   â”‚   â””â”€â”€ Tema01/           # Ejercicios del libro organizados por tema
â”‚   â”‚       â”œâ”€â”€ Ej01/
â”‚   â”‚       â”œâ”€â”€ Ej02/
â”‚   â”‚       â””â”€â”€ ...
â”‚   â”œâ”€â”€ ADNCalculator.hs      # Ejemplos varios
â”‚   â””â”€â”€ Lib.hs
â”œâ”€â”€ test/                      # Tests con HSpec
â”‚   â”œâ”€â”€ Exercises/
â”‚   â””â”€â”€ Spec.hs               # Entry point de tests
â”œâ”€â”€ app/
â”‚   â””â”€â”€ Main.hs               # Ejecutable principal
â”œâ”€â”€ flake.nix                 # âš™ï¸  Entorno de desarrollo Nix
â”œâ”€â”€ hie.yaml                  # ğŸ”§ Config HLS (estructura proyecto)
â”œâ”€â”€ fourmolu.yaml             # ğŸ¨ Estilo de formateo
â”œâ”€â”€ .envrc                    # ğŸ”„ ActivaciÃ³n automÃ¡tica direnv
â””â”€â”€ pensando-en-haskell.cabal # ğŸ“¦ DefiniciÃ³n del proyecto
#+end_example

-----

* ğŸ› Troubleshooting

** ~direnv: error .envrc is blocked~

#+begin_src bash
# Permitir direnv explÃ­citamente
direnv allow
#+end_src

** HLS no arranca en Doom Emacs

#+begin_src bash
# Verificar que HLS estÃ¡ en PATH
which haskell-language-server-wrapper

# DeberÃ­a mostrar: /home/tu-user/.nix-profile/bin/haskell-language-server-wrapper
#+end_src

En Emacs:
#+begin_example
M-x lsp-workspace-show-log  # Ver logs de LSP
M-x lsp-describe-session    # Ver estado de la sesiÃ³n
#+end_example

** ~GHC ABIs don't match!~ (IMPORTANTE)

Si ves este error:
#+begin_example
GHC ABIs don't match!
Expected: ghc-9.8.4:XXXXXXX
Got:      ghc-9.8.4:YYYYYYY
#+end_example

*Causa*: HLS fue compilado con una versiÃ³n de GHC diferente (aunque sea el mismo nÃºmero de versiÃ³n).

*SoluciÃ³n*:

1. *NUNCA* instalar HLS globalmente en home-manager si usas diferentes versiones de nixpkgs entre el sistema y los proyectos.

2. El flake *DEBE* usar ~nixos-25.05~ (stable) NO ~nixos-unstable~:

#+begin_src nix
inputs = {
  nixpkgs.url = "github:NixOS/nixpkgs/nixos-25.05";  # â† Importante
  flake-utils.url = "github:numtide/flake-utils";
};
#+end_src

3. HLS debe venir del ~pkgs~ top-level del flake:

#+begin_src nix
] ++ (with pkgs; [
  haskell-language-server  # â† Del mismo nixpkgs que GHC
#+end_src

*NO* usar ~hsPkgs.haskell-language-server~ (compilarÃ­a desde source y fallarÃ­a).

4. Asegurar que direnv/envrc estÃ¡ cargando el environment:

#+begin_src bash
# En el directorio del proyecto
direnv reload

# Verificar que cargÃ³
echo $IN_NIX_SHELL  # DeberÃ­a mostrar: impure
#+end_src

5. Reiniciar el daemon de Emacs completamente:

#+begin_src bash
emacsclient -e '(kill-emacs)'
# Esperar un momento
emacsclient -nw ~/src/pensando-en-haskell
#+end_src

** ~cabal: Could not resolve dependencies~

Significa que las versiones en ~build-depends~ no son compatibles.

*SoluciÃ³n 1*: Dejar que Cabal elija versiones automÃ¡ticamente:

#+begin_src cabal
build-depends: base >=4.7 && <5
             , text  -- Sin especificar versiÃ³n
#+end_src

*SoluciÃ³n 2*: Ver quÃ© versiÃ³n funciona:

#+begin_src bash
cabal build --allow-newer  # Permite versiones mÃ¡s nuevas
#+end_src

** Build muy lento la primera vez

*Normal*. La primera build descarga y compila dependencias (aeson, hspec, etc.). Las siguientes builds son rÃ¡pidas porque Cabal cachea todo.

#+begin_src bash
# Primera vez
cabal build  # ~2-5 minutos

# Siguientes veces
cabal build  # ~5-20 segundos (solo recompila cambios)
#+end_src

** ~git tree is dirty~ warning de direnv

Es solo un warning, no afecta. Significa que hay cambios sin commitear.

-----

* ğŸ“– Recursos de Aprendizaje

** Libros (ordenados por dificultad)

1. [[http://www.cs.us.es/~jalonso/publicaciones/Piensa_en_Haskell.pdf][Piensa en Haskell]] â­ - El libro de este repo (EN ESPAÃ‘OL)
2. [[http://learnyouahaskell.com/][Learn You a Haskell]] - Divertido, ilustrado, para empezar
3. [[https://haskellbook.com/][Haskell Programming from First Principles]] - El mÃ¡s completo (de pago)

** Cursos y Tutoriales

- [[https://github.com/haskell-beginners-2022/course-plan][Haskell Beginners 2022 Course]] - Curso completo gratis
- [[https://typeclasses.com/beginner-crash-course/types-and-functions-1][Type Classes - Beginner Crash Course]]
- [[https://www.fpcomplete.com/haskell/tutorial/][FP Complete - Haskell Tutorial]]

** Referencias RÃ¡pidas

- [[https://hoogle.haskell.org/][Hoogle]] - Busca funciones por nombre o tipo
- [[https://hackage.haskell.org/][Hackage]] - Repositorio de paquetes Haskell
- [[https://cheatsheet.codeslower.com/CheatSheet.pdf][Haskell Cheatsheet]]

-----

* ğŸ”§ Archivos de ConfiguraciÃ³n Explicados

** ~flake.nix~ - Entorno de desarrollo

Define quÃ© herramientas estÃ¡n disponibles en el proyecto. Usa *nixpkgs haskellPackages* (enfoque estÃ¡ndar Nix).

#+begin_src nix
{
  description = "Entorno Haskell con GHC 9.8";

  # GHC, cabal, fourmolu, hlint, ghcid, etc.
  # Se activan automÃ¡ticamente con direnv
}
#+end_src

*No necesitas tocarlo* a menos que quieras cambiar versiÃ³n de GHC o aÃ±adir herramientas del sistema.

** ~hie.yaml~ - ConfiguraciÃ³n HLS

Le dice a HLS cÃ³mo estÃ¡ estructurado tu proyecto (lib, exe, test).

#+begin_src yaml
cradle:
  cabal:
    - path: "./src"
      component: "lib:pensando-en-haskell"
    - path: "./test"
      component: "pensando-en-haskell:test:pensando-en-haskell-test"
#+end_src

*Regenerar si aÃ±ades componentes nuevos*:

#+begin_src bash
gen-hie > hie.yaml
#+end_src

** ~fourmolu.yaml~ - Estilo de cÃ³digo

ConfiguraciÃ³n del formateador (indentaciÃ³n, imports, etc.).

#+begin_src yaml
indentation: 2
comma-style: leading
diff-friendly-import-export: true
#+end_src

*Personalizar* segÃºn preferencias del equipo.

** ~pensando-en-haskell.cabal~ - DefiniciÃ³n del proyecto

El archivo mÃ¡s importante. Define:
- QuÃ© mÃ³dulos expone tu librerÃ­a (~exposed-modules~)
- Dependencias externas (~build-depends~)
- Ejecutables y tests

*Este sÃ­ lo editarÃ¡s* constantemente al aÃ±adir mÃ³dulos y dependencias.

-----

* ğŸ¤“ ApÃ©ndice: Por quÃ© este setup tÃ©cnico

** TL;DR: nixpkgs es suficiente para aprender

Este proyecto usa *nixpkgs haskellPackages*, el enfoque estÃ¡ndar de Nix para Haskell.

*Â¿Por quÃ© no Stack?*
- Stack y Nix juntos son incÃ³modos (ambos gestionan dependencias)
- Cabal es mÃ¡s simple y se integra mejor con Nix

*Â¿Por quÃ© no haskell.nix?*
- MÃ¡s complejo (IFD, materializaciÃ³n, cache propio)
- Overkill para aprender Haskell
- haskell.nix es para cross-compilation y proyectos industriales

*Â¿Por quÃ© no haskell-flake?*
- Es buena opciÃ³n, pero aÃ±ade abstracciÃ³n extra
- Para este proyecto educativo, nixpkgs raw es suficiente y mÃ¡s directo

** ComparaciÃ³n rÃ¡pida de enfoques Nix+Haskell

| Enfoque              | Complejidad | Mejor para                   | Flexibilidad |
|----------------------+-------------+------------------------------+--------------|
| *nixpkgs* â­         | Baja        | Proyectos estÃ¡ndar, aprender | Media        |
| *haskell-flake*      | Media       | Equipos, monorepos           | Media        |
| *haskell.nix*        | Alta        | Cross-compilation, industria | MÃ¡xima       |

*Para aprender Haskell*: nixpkgs es perfecto. Simple, cacheado, reproducible.

*Para producciÃ³n/empresa*: Considera haskell-flake o haskell.nix segÃºn necesidades.

** Trade-off: Consistencia vs Libertad

*nixpkgs*: Un conjunto consistente de paquetes (como una distribuciÃ³n Linux)
- âœ… Todo funciona junto sin conflictos
- âœ… Cache binario excelente (builds rÃ¡pidos)
- âŒ Solo versiones del snapshot (actualmente GHC 9.8)
- âŒ Ignora restricciones de versiÃ³n de Cabal

*haskell.nix*: Libertad total (como compilar todo desde source)
- âœ… Cualquier versiÃ³n de cualquier paquete
- âœ… Respeta restricciones exactas de Cabal
- âŒ MÃ¡s complejo (IFD, materializaciÃ³n)
- âŒ Cache menos completo

*Este proyecto*: nixpkgs es suficiente porque:
1. No necesitamos versiones especÃ­ficas raras
2. Aprendiendo Haskell, no manteniendo software crÃ­tico
3. Queremos setup simple que funcione

Si algÃºn dÃ­a necesitas haskell.nix, la migraciÃ³n es posible (pero este README ya serÃ­a otro).

-----

* ğŸ“ FilosofÃ­a del Repo

*Objetivo*: Bajar la barrera de entrada a Haskell.

La configuraciÃ³n de entorno en Haskell puede ser frustrante. Este repo ofrece:
- âœ… Setup que funciona out-of-the-box
- âœ… Ejemplos reales de ejercicios
- âœ… Tests como documentaciÃ³n
- âœ… Herramientas modernas (HLS, ghcid, formatters)

*No es*: Un template perfecto para producciÃ³n.

*Es*: Un entorno cÃ³modo para aprender sin pelear con tooling.

-----

* ğŸ¤ Contribuir

Â¿Encontraste un error? Â¿MejorarÃ­as algo? *Â¡PR bienvenidos!*

Ãreas donde ayuda serÃ­a genial:
- MÃ¡s ejercicios resueltos con tests
- Explicaciones en espaÃ±ol de conceptos difÃ­ciles
- Mejoras al README (siempre se puede mejorar)
- Alternativas de setup mÃ¡s simples

-----

* ğŸ“œ Licencia

MIT - Haz lo que quieras con este cÃ³digo.

-----

*Â¡Feliz Haskelling! ğŸš€*

Si este repo te sirviÃ³, dale una â­ para que otros noobskells lo encuentren.

* ğŸ¬ Scripting: Probar librerÃ­as sin tocar el proyecto

** El problema

Quieres probar =http-conduit= pero no estÃ¡s seguro si te gusta. Â¿Tienes que:
1. AÃ±adirlo al =.cabal=
2. =cabal build= (esperar)
3. Probarlo
4. Si no te gusta, quitarlo del =.cabal=?

*NO.* Hay una forma mejor.

** La soluciÃ³n: Scripts con Nix shell

Crea un script que se ejecuta directamente, con sus propias dependencias:

#+begin_src haskell
#!/usr/bin/env nix-shell
#! nix-shell -i runghc -p "haskellPackages.ghcWithPackages (p: [p.http-conduit])"

import Network.HTTP.Simple

main = httpLBS "https://api.github.com" >>= print
#+end_src

#+begin_src bash
chmod +x mi-script.hs
./mi-script.hs  # â† Descarga deps y ejecuta (primera vez tarda, luego rÃ¡pido)
#+end_src

** âœ… Ventajas

- *NO necesitas =nix develop=*
- *NO tocas el =.cabal=*
- *Pruebas la librerÃ­a* y si te gusta, la aÃ±ades al proyecto
- *Prototipado rÃ¡pido*

** ğŸ“¦ Ejemplos en =scripting/=

*** =http-nix.hs= - Peticiones HTTP

#+begin_src bash
./scripting/http-nix.hs
# Hace una peticiÃ³n HTTP y muestra el resultado
#+end_src

*** =json-example.hs= - Parsear JSON

#+begin_src bash
./scripting/json-example.hs
# Parsea JSON con aeson
#+end_src

*** =text-example.hs= - Procesar texto

#+begin_src bash
./scripting/text-example.hs
# Usa la librerÃ­a 'text' (mÃ¡s eficiente que String)
#+end_src

*** =SKELETON.hs= - Template para tus scripts

Copia y adapta:

#+begin_src bash
cp scripting/SKELETON.hs scripting/mi-experimento.hs
# Edita y aÃ±ade las librerÃ­as que quieras probar
chmod +x scripting/mi-experimento.hs
./scripting/mi-experimento.hs
#+end_src

** ğŸ¯ Workflow tÃ­pico

#+begin_example
1. Ves una librerÃ­a interesante en Hackage (ej: cassava para CSV)
2. Creas script rÃ¡pido para probarla:
   cp scripting/SKELETON.hs scripting/prueba-csv.hs
3. Cambias la lÃ­nea del shebang:
   #! nix-shell -i runghc -p "haskellPackages.ghcWithPackages (p: [p.cassava])"
4. Escribes cÃ³digo de prueba
5. ./scripting/prueba-csv.hs
6. Â¿Te gusta? â†’ Lo aÃ±ades al .cabal del proyecto
   Â¿No te gusta? â†’ Borras el script, no tocaste nada del proyecto
#+end_example

** ğŸ’¡ Tip: Buscar paquetes

#+begin_src bash
# Buscar paquetes disponibles en Nix
nix search nixpkgs haskellPackages.cassava
nix search nixpkgs haskellPackages.lens

# O en Hackage
# https://hackage.haskell.org/
#+end_src

-----

* ğŸ› Debugging en Haskell

** La verdad incÃ³moda

*Debugging en Haskell es MUY diferente a PHP/JavaScript.*

En lenguajes imperativos: pones breakpoints, ves el estado, modificas variables.

En Haskell: *no funciona asÃ­.* Y estÃ¡ bien.

** Â¿Por quÃ© es diferente?

1. *Funciones puras* - No hay "estado" que inspeccionar
2. *Inmutabilidad* - Las variables no cambian
3. *Lazy evaluation* - El cÃ³digo no se ejecuta cuando crees
4. *Los tipos previenen el 90% de los bugs*

** ğŸ¯ CÃ³mo debuggean los Haskellers (de verdad)

*** 1. REPL-Driven Development â­ (lo mÃ¡s usado)

#+begin_src bash
cabal repl
ghci> :l src/MiModulo.hs
ghci> miFuncion [1,2,3]  # Pruebas la funciÃ³n directamente
ghci> :t miFuncion        # Ves el tipo
ghci> :i TipoCustom       # Ves info sobre tipos
#+end_src

*Workflow real*:
1. Escribes funciÃ³n
2. =:r= en GHCi (recarga)
3. Pruebas con inputs diferentes
4. Ajustas
5. Repites

*** 2. Type-Driven Development (prevenciÃ³n > curaciÃ³n)

#+begin_src haskell
-- Escribes el tipo PRIMERO
sumaLista :: [Int] -> Int

-- El compilador te guÃ­a para implementarlo
sumaLista [] = 0
sumaLista (x:xs) = x + sumaLista xs

-- Si compila, probablemente funciona
#+end_src

*El compilador ES tu debugger.*

*** 3. QuickCheck (testing basado en propiedades)

En lugar de debuggear, *pruebas que tu funciÃ³n cumple propiedades*:

#+begin_src haskell
import Test.QuickCheck

-- Propiedad: reverse dos veces = identidad
prop_reverseReverse :: [Int] -> Bool
prop_reverseReverse xs = reverse (reverse xs) == xs

-- QuickCheck genera 100 casos de prueba random
main = quickCheck prop_reverseReverse
#+end_src

#+begin_src bash
cabal repl
ghci> quickCheck prop_reverseReverse
+++ OK, passed 100 tests.
#+end_src

*** 4. Debug.Trace (print debugging cuando es necesario)

#+begin_src haskell
import Debug.Trace

factorial :: Int -> Int
factorial n = trace ("llamando factorial " ++ show n) $
    if n <= 1
        then 1
        else n * factorial (n - 1)

-- Ejecutar:
factorial 5
-- Output:
-- llamando factorial 5
-- llamando factorial 4
-- llamando factorial 3
-- ...
-- 120
#+end_src

*Tip*: =traceShow= es mÃ¡s conveniente:

#+begin_src haskell
import Debug.Trace (traceShow)

miFuncion x = traceShow x $ x * 2
#+end_src

*** 5. GHCi Debugger (existe pero casi nadie lo usa)

#+begin_src bash
ghci> :break miFuncion
ghci> :step miFuncion 10
ghci> :continue
#+end_src

*Por quÃ© nadie lo usa*:
- Lazy evaluation hace que sea confuso
- REPL + tipos + QuickCheck son mejores

** ğŸ”§ En Doom Emacs

*** Lo que SÃ tienes (y usarÃ¡s):

| Comando | DescripciÃ³n |
|---------+-------------|
| =M-x run-haskell= | Abrir REPL |
| =C-c C-l= | Cargar archivo en REPL |
| =C-c C-t= | Ver tipo en REPL |
| =K= (sobre funciÃ³n) | Ver tipo (con LSP) |
| =SPC c x= | Ver errores de compilaciÃ³n |

*** Lo que NO necesitas (realmente):

- *DAP (Debug Adapter Protocol)* - Existe para Haskell pero casi nadie lo usa
- *Breakpoints visuales* - No funciona bien con lazy evaluation
- *Step debugging* - REPL es mejor

** ğŸ“ Ejemplo de debugging real

*Problema*: Tengo un bug en esta funciÃ³n:

#+begin_src haskell
-- DeberÃ­a sumar solo los pares, pero devuelve un nÃºmero raro
sumaPares :: [Int] -> Int
sumaPares xs = sum $ filter even xs
#+end_src

*Debugging en Haskell*:

#+begin_example
1. Abro REPL: M-x run-haskell
2. Cargo: :l src/MiModulo.hs
3. Pruebo: sumaPares [1,2,3,4,5,6]
   â†’ Output: 12  (correcto: 2+4+6=12)
4. Pruebo caso edge: sumaPares []
   â†’ Output: 0  (correcto)
5. Pruebo negativos: sumaPares [-2,-1,0,1,2]
   â†’ Output: 0  (Â¡bug! deberÃ­a ser -2+0+2=0... wait, es correcto)
6. No hay bug, era mi expectativa equivocada
#+end_example

*Si hubiera bug real*:

#+begin_src haskell
import Debug.Trace

sumaPares :: [Int] -> Int
sumaPares xs = traceShow xs $           -- Ver input
    sum $ traceShow pares $ pares       -- Ver pares filtrados
  where pares = filter even xs
#+end_src

** ğŸ“ FilosofÃ­a

En Haskell:
- *Escribes menos bugs* (tipos fuertes, pureza)
- *Cuando hay bugs*, el REPL + tipos + tests los encuentran rÃ¡pido
- *Debuggers tradicionales* (breakpoints, step) no son necesarios

*Es diferente, pero mejor.*

** ğŸ“š Recursos

- [[https://wiki.haskell.org/Debugging][Haskell Wiki - Debugging]]
- [[https://downloads.haskell.org/ghc/latest/docs/users_guide/ghci.html#the-ghci-debugger][GHC User Guide - GHCi Debugger]]
- [[https://hackage.haskell.org/package/QuickCheck][QuickCheck en Hackage]]

-----


* ğŸ§ª Testing Avanzado: HSpec, QuickCheck, Coverage

** Tests con HSpec (ya los tienes)

Tu proyecto usa *HSpec*, un framework de testing tipo RSpec (Ruby) o Jest (JS).

*** Estructura de un test

#+begin_src haskell
-- test/MiModuloSpec.hs
module MiModuloSpec (spec) where

import Test.Hspec
import MiModulo

spec :: Spec
spec = describe "miFuncion" $ do
    it "suma dos nÃºmeros" $
        miFuncion 2 3 `shouldBe` 5

    it "maneja cero" $
        miFuncion 0 0 `shouldBe` 0

    it "maneja negativos" $
        miFuncion (-2) 3 `shouldBe` 1
#+end_src

*** Matchers disponibles

#+begin_src haskell
-- Igualdad
resultado `shouldBe` 42

-- Booleanos
esValido `shouldBe` True
esValido `shouldSatisfy` (> 0)

-- Listas
lista `shouldContain` [2, 3]
length lista `shouldBe` 5

-- Excepciones
evaluate (1 `div` 0) `shouldThrow` anyException

-- Strings
texto `shouldStartWith` "Hola"
texto `shouldEndWith` "mundo"
#+end_src

** Tests con QuickCheck (property-based)

*QuickCheck* genera cientos de casos de prueba automÃ¡ticamente.

*** AÃ±adir QuickCheck a un test de HSpec

#+begin_src haskell
import Test.Hspec
import Test.QuickCheck

spec :: Spec
spec = describe "reverse" $ do
    it "dos veces es identidad" $ property $
        \xs -> reverse (reverse xs) == (xs :: [Int])

    it "preserva longitud" $ property $
        \xs -> length (reverse xs) == length (xs :: [Int])
#+end_src

*** Propiedades Ãºtiles comunes

#+begin_src haskell
-- Idempotencia: f(f(x)) = f(x)
prop_idempotent f x = f (f x) == f x

-- Inversa: f(g(x)) = x
prop_inverse f g x = f (g x) == x

-- Conmutatividad: f(a,b) = f(b,a)
prop_commutative f a b = f a b == f b a

-- Asociatividad: f(f(a,b),c) = f(a,f(b,c))
prop_associative f a b c = f (f a b) c == f a (f b c)
#+end_src

** Ejecutar tests

*** BÃ¡sico

#+begin_src bash
cabal test
#+end_src

*** Con detalles (ver cada test)

#+begin_src bash
cabal test --test-show-details=direct
#+end_src

*** Con streaming (ver en tiempo real)

#+begin_src bash
cabal test --test-show-details=streaming
#+end_src

*** Solo un test especÃ­fico

#+begin_src bash
# Ejecutar solo tests que contengan "palindromo"
cabal test --test-options="--match palindromo"
#+end_src

*** Tests en loop con ghcid

#+begin_src bash
# Tests se reejec

utan automÃ¡ticamente al guardar
ghcid --command='cabal repl pensando-en-haskell-test' --test='main'
#+end_src

** Coverage (cobertura de tests)

*** Generar reporte de coverage

#+begin_src bash
# Compilar con cobertura
cabal test --enable-coverage

# El reporte HTML estÃ¡ en:
# dist-newstyle/build/.../hpc/vanilla/html/pensando-en-haskell-test/hpc_index.html
#+end_src

*** Ver cobertura en terminal

#+begin_src bash
cabal test --enable-coverage
hpc report dist-newstyle/build/*/pensando-en-haskell-*/t/pensando-en-haskell-test/test/pensando-en-haskell-test.tix
#+end_src

*** Abrir reporte HTML

#+begin_src bash
cabal test --enable-coverage
firefox $(find dist-newstyle -name "hpc_index.html" | head -1)
#+end_src

** Benchmarking (medir rendimiento)

Si quieres medir rendimiento, usa *criterion*:

*** AÃ±adir benchmark al .cabal

#+begin_src cabal
benchmark pensando-en-haskell-bench
  type: exitcode-stdio-1.0
  main-is: Bench.hs
  hs-source-dirs: bench
  build-depends:
      base
    , pensando-en-haskell
    , criterion
  ghc-options: -O2 -threaded
#+end_src

*** Ejemplo de benchmark

#+begin_src haskell
-- bench/Bench.hs
import Criterion.Main
import MiModulo

main = defaultMain [
  bgroup "suma" 
    [ bench "suma simple" $ whnf (sum) [1..1000]
    , bench "suma con fold" $ whnf (foldl (+) 0) [1..1000]
    ]
  ]
#+end_src

#+begin_src bash
cabal bench
#+end_src

-----

* ğŸ“š Comandos de Cabal que debes conocer

** Build y compilaciÃ³n

#+begin_src bash
cabal build                    # Compilar todo
cabal build lib:pensando-en-haskell  # Solo la librerÃ­a
cabal build exe:pensando-en-haskell-exe  # Solo el ejecutable
cabal build --ghc-options="-Wall"  # Con warnings extras

cabal clean                    # Limpiar builds (si algo va raro)
cabal build --enable-profiling # Compilar con profiling
#+end_src

** Ejecutar

#+begin_src bash
cabal run pensando-en-haskell-exe       # Ejecutar
cabal run pensando-en-haskell-exe -- arg1 arg2  # Con argumentos
#+end_src

** REPL

#+begin_src bash
cabal repl                     # REPL con la librerÃ­a cargada
cabal repl pensando-en-haskell-exe  # REPL del ejecutable
cabal repl pensando-en-haskell-test # REPL de tests

# Dentro del REPL:
:r                             # Recargar cambios
:t expresion                   # Ver tipo
:i Tipo                        # Info sobre tipo/clase
:browse Modulo                 # Ver exports de mÃ³dulo
:!comando                      # Ejecutar comando shell
#+end_src

** Tests

#+begin_src bash
cabal test                     # Ejecutar tests
cabal test --test-show-details=direct  # Ver detalles
cabal test --test-options="--match nombre"  # Solo tests que coincidan
cabal test --enable-coverage   # Con coverage
#+end_src

** Dependencias

#+begin_src bash
# Ver dependencias del proyecto
cabal build --dry-run

# Ver quÃ© versiones estÃ¡n instaladas
ghc-pkg list

# Congelar versiones exactas (para reproducibilidad)
cabal freeze
# Crea cabal.project.freeze con versiones exactas

# Ver dependencias desactualizadas
cabal outdated
#+end_src

** DocumentaciÃ³n

#+begin_src bash
# Generar documentaciÃ³n HTML (como Hackage)
cabal haddock

# Abrir documentaciÃ³n generada
firefox dist-newstyle/build/*/pensando-en-haskell-*/doc/html/pensando-en-haskell/index.html
#+end_src

** Otros Ãºtiles

#+begin_src bash
# Ver info del proyecto
cabal info pensando-en-haskell

# Instalar ejecutable globalmente
cabal install pensando-en-haskell-exe

# Formatear el .cabal
cabal-fmt -i pensando-en-haskell.cabal

# Listar todos los targets
cabal build --dry-run -v0 | grep "^   "
#+end_src

-----

* ğŸ“ Conceptos de Haskell que DEBES saber

** Tipos bÃ¡sicos

#+begin_src haskell
-- NÃºmeros
42 :: Int              -- Entero con lÃ­mite
42 :: Integer          -- Entero arbitrariamente grande
3.14 :: Double         -- Float de doble precisiÃ³n

-- Strings y chars
'a' :: Char            -- Un carÃ¡cter
"hola" :: String       -- String = [Char] (lista de chars)

-- Booleanos
True :: Bool
False :: Bool

-- Listas
[1, 2, 3] :: [Int]     -- Lista de enteros
[] :: [a]              -- Lista vacÃ­a (de cualquier tipo)

-- Tuplas
(1, "hola") :: (Int, String)
(1, 2, 3) :: (Int, Int, Int)

-- Unit (como void)
() :: ()               -- Valor Ãºnico, tipo Ãºnico

-- Maybe (puede ser Nothing o Just algo)
Just 5 :: Maybe Int
Nothing :: Maybe Int

-- Either (puede ser Left o Right)
Left "error" :: Either String Int
Right 42 :: Either String Int
#+end_src

** Funciones

#+begin_src haskell
-- DeclaraciÃ³n de tipo
suma :: Int -> Int -> Int
suma x y = x + y

-- AplicaciÃ³n (sin parÃ©ntesis ni comas!)
suma 2 3  -- â†’ 5

-- AplicaciÃ³n parcial
suma2 = suma 2     -- suma2 :: Int -> Int
suma2 3            -- â†’ 5

-- Funciones de orden superior
map :: (a -> b) -> [a] -> [b]
map (+1) [1,2,3]   -- â†’ [2,3,4]

filter :: (a -> Bool) -> [a] -> [a]
filter even [1,2,3,4]  -- â†’ [2,4]

-- ComposiciÃ³n
(.) :: (b -> c) -> (a -> b) -> (a -> c)
(suma 2 . (*3)) 5  -- â†’ 17  (primero *3, luego +2)
#+end_src

** Pattern Matching

#+begin_src haskell
-- En listas
suma [] = 0
suma (x:xs) = x + suma xs

-- En Maybe
mostrar Nothing = "nada"
mostrar (Just x) = "valor: " ++ show x

-- En tuplas
primero (x, _) = x
segundo (_, y) = y

-- Guards (condiciones)
absoluto x
    | x < 0     = -x
    | otherwise = x

-- Case
case maybeValor of
    Nothing -> "sin valor"
    Just x  -> "valor: " ++ show x
#+end_src

** Lazy Evaluation (IMPORTANTE)

Haskell es *lazy*: no evalÃºa nada hasta que es necesario.

#+begin_src haskell
-- Listas infinitas (Â¡sÃ­, infinitas!)
[1..]              -- [1,2,3,4,5,6,7,8,...]
take 5 [1..]       -- â†’ [1,2,3,4,5]

-- Esto NO explota, solo toma los primeros 3
take 3 [1..]       -- â†’ [1,2,3]

-- Fibonacci infinito
fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
take 10 fibs       -- â†’ [0,1,1,2,3,5,8,13,21,34]
#+end_src

** Purity (funciones puras)

#+begin_src haskell
-- FunciÃ³n pura: mismo input â†’ mismo output, sin efectos
suma :: Int -> Int -> Int
suma x y = x + y   -- SIEMPRE devuelve lo mismo con los mismos argumentos

-- FunciÃ³n impura (necesita IO)
main :: IO ()
main = do
    putStrLn "Â¿CÃ³mo te llamas?"
    nombre <- getLine           -- Lee de stdin
    putStrLn $ "Hola, " ++ nombre

-- NO puedes llamar cÃ³digo IO desde cÃ³digo puro
-- Esto NO compila:
impuro :: Int
impuro = putStrLn "hola"  -- ERROR: tipos no coinciden
#+end_src

** Do Notation (para IO y Monads)

#+begin_src haskell
main :: IO ()
main = do
    -- Cada lÃ­nea es una acciÃ³n IO
    putStrLn "lÃ­nea 1"
    putStrLn "lÃ­nea 2"
    
    -- <- extrae valor de IO
    nombre <- getLine
    let nombreMayus = map toUpper nombre  -- let NO tiene <-
    
    putStrLn nombreMayus

-- Equivalente sin do:
main = 
    putStrLn "lÃ­nea 1" >>
    putStrLn "lÃ­nea 2" >>
    getLine >>= \nombre ->
    let nombreMayus = map toUpper nombre in
    putStrLn nombreMayus
#+end_src

** List Comprehensions

#+begin_src haskell
-- Como en Python/matemÃ¡ticas
[x * 2 | x <- [1..10]]
-- â†’ [2,4,6,8,10,12,14,16,18,20]

-- Con filtro
[x | x <- [1..10], even x]
-- â†’ [2,4,6,8,10]

-- MÃºltiples generadores
[(x, y) | x <- [1,2,3], y <- [4,5,6]]
-- â†’ [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]

-- PitagÃ³ricos
[(a,b,c) | a <- [1..20], b <- [1..20], c <- [1..20], a^2 + b^2 == c^2]
#+end_src

-----

* ğŸš¨ Errores comunes y cÃ³mo leerlos

** Error: "Couldn't match expected type..."

#+begin_example
error:
    â€¢ Couldn't match expected type 'Int' with actual type '[Char]'
    â€¢ In the expression: "42"
      In an equation for 'x': x = "42"
#+end_example

*QuÃ© significa*: Esperaba un =Int= pero le diste un =String=.

*SoluciÃ³n*: Convierte tipos o corrige la anotaciÃ³n de tipo.

#+begin_src haskell
-- Mal
x :: Int
x = "42"

-- Bien
x :: Int
x = 42

-- O si necesitas convertir
x :: Int
x = read "42"  -- Convierte String a Int
#+end_src

** Error: "No instance for (Show ...)"

#+begin_example
error:
    â€¢ No instance for (Show (a -> b))
        arising from a use of 'print'
#+end_example

*QuÃ© significa*: Intentas imprimir algo que no se puede mostrar (como una funciÃ³n).

*SoluciÃ³n*: No imprimas funciones. Imprime el *resultado* de aplicar la funciÃ³n.

#+begin_src haskell
-- Mal
main = print suma  -- ERROR: no puedes imprimir funciones

-- Bien
main = print (suma 2 3)  -- Imprime el resultado: 5
#+end_src

** Error: "Parse error on input..."

#+begin_example
error: parse error on input '='
#+end_example

*QuÃ© significa*: Sintaxis incorrecta (parÃ©ntesis, indentaciÃ³n, etc.).

*SoluciÃ³n*: Revisa:
- IndentaciÃ³n (Haskell es sensible a indentaciÃ³n)
- ParÃ©ntesis balanceados
- Comas en listas

#+begin_src haskell
-- Mal (indentaciÃ³n incorrecta)
suma x y =
x + y  -- ERROR: debe estar indentado

-- Bien
suma x y =
    x + y
#+end_src

** Error: "Ambiguous occurrence..."

#+begin_example
error:
    Ambiguous occurrence 'head'
    It could refer to either 'Prelude.head' or 'Data.List.head'
#+end_example

*SoluciÃ³n*: Importa con qualified o especÃ­fico.

#+begin_src haskell
-- OpciÃ³n 1: Import qualified
import qualified Data.List as L
L.head [1,2,3]

-- OpciÃ³n 2: Import especÃ­fico
import Data.List (sort)  -- Solo sort, no head
#+end_src

** Error: "Non-exhaustive patterns"

#+begin_example
*** Exception: Non-exhaustive patterns in function miFuncion
#+end_example

*QuÃ© significa*: Tu pattern matching no cubre todos los casos.

#+begin_src haskell
-- Mal (Â¿quÃ© pasa si la lista estÃ¡ vacÃ­a?)
primero (x:xs) = x  -- ERROR en runtime con []

-- Bien
primero (x:xs) = Just x
primero []     = Nothing
#+end_src

-----

* ğŸ¯ Cheatsheet: Sintaxis rÃ¡pida

** Declaraciones

#+begin_src haskell
-- Variable
x = 42

-- FunciÃ³n
suma x y = x + y

-- Con tipo
suma :: Int -> Int -> Int
suma x y = x + y

-- Let (local)
resultado = let x = 10
                y = 20
            in x + y

-- Where (al final)
resultado = x + y
  where
    x = 10
    y = 20
#+end_src

** Listas

#+begin_src haskell
[1, 2, 3]          -- Lista literal
1 : [2, 3]         -- Cons (agregar al inicio)
[1, 2] ++ [3, 4]   -- Concatenar
head [1,2,3]       -- Primer elemento: 1
tail [1,2,3]       -- Resto: [2,3]
take 2 [1,2,3,4]   -- Primeros n: [1,2]
drop 2 [1,2,3,4]   -- Sin primeros n: [3,4]
length [1,2,3]     -- Longitud: 3
reverse [1,2,3]    -- Invertir: [3,2,1]
#+end_src

** Funciones de orden superior

#+begin_src haskell
map (+1) [1,2,3]              -- [2,3,4]
filter even [1,2,3,4]         -- [2,4]
foldr (+) 0 [1,2,3]           -- 6 (suma)
zip [1,2,3] ["a","b","c"]     -- [(1,"a"),(2,"b"),(3,"c")]
zipWith (+) [1,2,3] [4,5,6]   -- [5,7,9]
#+end_src

** Operadores Ãºtiles

#+begin_src haskell
$   -- AplicaciÃ³n (evita parÃ©ntesis)
f $ g $ h x  â‰¡  f (g (h x))

.   -- ComposiciÃ³n
(f . g) x  â‰¡  f (g x)

<$> -- Map (fmap)
(+1) <$> [1,2,3]  â‰¡  map (+1) [1,2,3]

<*> -- Aplicativo
[(+1), (+2)] <*> [10, 20]  â†’  [11,21,12,22]

>>= -- Bind (Monad)
Just 5 >>= \x -> Just (x + 1)  â†’  Just 6
#+end_src

-----

* ğŸ“– Recursos organizados por nivel

** Nivel 0: Nunca programÃ© en Haskell

1. [[http://learnyouahaskell.com/][Learn You a Haskell]] - Tutorial ilustrado, divertido
2. [[http://www.cs.us.es/~jalonso/publicaciones/Piensa_en_Haskell.pdf][Piensa en Haskell]] - En espaÃ±ol, acadÃ©mico
3. [[https://www.youtube.com/watch?v=02_H3LjqMr8][Haskell in 100 Seconds]] - Video overview

** Nivel 1: Hice algunos ejercicios

1. [[https://github.com/haskell-beginners-2022/course-plan][Haskell Beginners Course 2022]] - Curso completo gratis
2. [[https://exercism.org/tracks/haskell][Exercism - Haskell Track]] - Ejercicios con mentores
3. [[https://www.haskelltutorials.com/][Haskell Tutorials]] - ColecciÃ³n de tutoriales

** Nivel 2: Entiendo lo bÃ¡sico, quiero mÃ¡s

1. [[https://haskellbook.com/][Haskell Programming from First Principles]] - El libro definitivo (de pago)
2. [[https://github.com/data61/fp-course][Data61 FP Course]] - Curso hardcore de FP
3. [[https://typeclasses.com/][Type Classes]] - Tutoriales avanzados

** Nivel 3: Quiero hacer proyectos reales

1. [[https://lexi-lambda.github.io/blog/][Alexis King's Blog]] - ArtÃ­culos avanzados
2. [[https://www.parsonsmatt.org/][Matt Parsons' Blog]] - Patterns de producciÃ³n
3. [[https://www.fpcomplete.com/haskell/][FP Complete Guides]] - GuÃ­as prÃ¡cticas

** Herramientas de referencia

- [[https://hoogle.haskell.org/][Hoogle]] - Buscar funciones por tipo
- [[https://hackage.haskell.org/][Hackage]] - Repositorio de paquetes
- [[https://www.stackage.org/][Stackage]] - Paquetes curados (compatibles)
- [[https://cheatsheet.codeslower.com/][Haskell Cheatsheet]] - Sintaxis rÃ¡pida

** Comunidades

- [[https://discourse.haskell.org/][Haskell Discourse]] - Foro oficial
- [[https://www.reddit.com/r/haskell/][r/haskell]] - Reddit activo
- [[https://wiki.haskell.org/IRC_channel][#haskell en Libera.Chat]] - IRC
- [[https://haskell.foundation/][Haskell Foundation]] - OrganizaciÃ³n oficial

-----

